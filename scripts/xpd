#!/usr/bin/python
from stat import ST_MODE
from stat import S_IWRITE

from optparse import OptionParser
import os, subprocess, sys, re
import difflib
import zipfile
import tempfile
from copy import copy
from xpd.xpd_data import Repo, Release, Version, Dependency
import xpd.check_project
from xpd.xpd_subprocess import call, Popen
import xpd.xmlobject
from xpd import templates

def samefile(fileA, fileB):
    try:
        return os.path.samefile(fileA, fileB)
    except AttributeError:
        return os.path.abspath(fileA).lower() == os.path.abspath(fileB).lower()


def confirm(msg, default=False):
    x = raw_input(msg)
    if (x in ["n","N","no","No","NO"]):
        return False
    if (x in ["y","Y","yes","Yes","YES"]):
        return True
    return default


def xpd_dep_iter(repo, command, output_repo_names=True):
    deps = repo.dependencies
    os.system(command)
    for dep in deps:
        cwd = os.getcwd()
        os.chdir(dep.get_local_path())
        if output_repo_names:
            sys.stdout.write("\n"+str(dep)+":\n")
        os.system(command)
        os.chdir(cwd)

def xpd_show_dep(repo, options, args):

    if repo.dependencies == []:
        print "No dependencies"
    else:
        print "Actual:"
        for dep in repo.dependencies:
            if dep.repo:
                rel = dep.repo.current_release()
                if dep.repo.has_local_modifications():
                    local_mod = "(local modifications)"
                else:
                    local_mod = ""
                if rel:
                    print "%20s: %s %s"%(dep.repo, rel.version, local_mod)
                else:
                    print "%20s: %s %s"%(dep.repo, dep.repo.current_githash(),local_mod)

        print "\nExpected:"
        for dep in repo.dependencies:
            if dep.version_str:
                print "%20s: %s"%(dep.repo_name, dep.version_str)
            else:
                print "%20s: %s"%(dep.repo_name, dep.githash)



def xpd_remove_dep(repo, options, args):
    if len(args) < 1:
        return False
    to_remove = args[0]
    deps = repo.dependencies

    for d in deps:
        if d.repo_name == to_remove:
            deps.remove(d)
            print "Removed"
            return True

    sys.stderr.write("%s is not a current dependency\n" % to_remove)
    return False


def get_current_modules(repo):
    makefiles = []
    for root, dirs, files in os.walk(repo.path, topdown=False):
        for f in files:
            if f=="Makefile":
                makefiles.append(os.path.join(root,f))

    modules = set([])
    for path in makefiles:
        f = open(path)
        while True:
            line = f.readline()
            if line=="":
                break
            m = re.match(r'\s*USED_MODULES\s*\+?=(.*)', line)
            if m:
                s = m.groups(0)[0]
                ms = [m for m in s.split(' ') if m != '']
                modules = modules | set(ms)
            if re.match(r'.*include.*module_xcommon', line):
                modules.add('module_xcommon')
        f.close()

    return modules

def find_current_dependencies(repo):
    modules = get_current_modules(repo)

    root_dir = os.path.join(repo.path,"..")

    repos = set([])
    for dep_repo in os.listdir(root_dir):
        repo_path = os.path.join(root_dir,dep_repo)
        if os.path.isdir(repo_path):
            for module_dir in os.listdir(repo_path):
                if os.path.isdir(os.path.join(repo_path,module_dir)):
                    if module_dir in modules:
                        modules.remove(module_dir)
                        if not samefile(repo_path, repo.path):
                            repos.add(dep_repo)

    if len(modules) != 0:
        print "WARNING: Can't find repos for the following modules:"
        for m in modules:
            print "   " + m

    return repos

def xpd_add_dep(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("ERROR: required repo name")
        exit(1)

    for dep in repo.dependencies:
        if dep.repo_name == args[0]:
            sys.stderr.write("ERROR: dependency already exists")
            exit(1)


    dep = Dependency(parent=repo)
    dep.repo_name = args[0]
    dep.repo = Repo(dep.get_local_path())
    dep.uri = dep.repo.uri()
    dep.githash = dep.repo.current_githash()
    rel = dep.repo.current_release()
    if rel:
        dep.version_str = str(rel.version)
    repo.dependencies.append(dep)
    print "Added"
    return True


def xpd_check_dep(repo, options, args, return_current_ok=False,
                   allow_updates=True):
    deps = [d.repo_name for d in repo.dependencies]

    current_ok = True
    repos = find_current_dependencies(repo)

    repos = repos - set(deps)
    update = False
    for dep_repo in repos:


        if allow_updates and \
           confirm("Add %s to dependencies (Y/n)?"%dep_repo,default=True):
            dep = Dependency(parent=repo)
            dep.repo_name = dep_repo
            dep.repo = Repo(dep.get_local_path())
            dep.uri = dep.repo.uri()
            dep.githash = dep.repo.current_githash()
            rel = dep.repo.current_release()
            if rel:
                dep.version_str = str(rel.version)
            repo.dependencies.append(dep)
            print "Added"
            update = True
        else:
            if not allow_updates:
                print "Dependency %s is not up to date" % dep_repo
            if dep_repo != "xcommon":
                current_ok = False

    for dep in [d for d in repo.dependencies if d.repo]:
        rel = dep.repo.current_release()
        if dep.githash != dep.repo.current_githash() or \
           (rel and dep.version_str != str(rel.version)):
            if allow_updates and \
               confirm("%s has new local version. Update metainformation (Y/n)?"%dep.repo_name,
                       default=True):
                dep.githash = dep.repo.current_githash()
                if rel:
                    dep.version_str = str(rel.version)
                else:
                    dep.version_str = None
                update = True
            else:
                if not allow_updates:
                    print "Dependency %s is not up to date" % dep.repo_name
                current_ok = False


    if len(repos) == 0 and current_ok and not update:
        print "Dependencies OK"

    if return_current_ok:
        return current_ok
    else:
        return update


def xpd_list(repo, options, args):
    rels = repo.releases
    rels.sort()
    rels.reverse()
    for rel in rels:
        print rel.version

def xpd_upgrade_rc(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("Requires version number.\n")
        exit(1)

    version = Version(version_str=args[0])

    version.rtype = ''
    version.rnumber = 0

    if repo.get_release(version):
        sys.stderr.write("Version already exists.\n")
        exit(1)


    rc = repo.latest_release(release_filter=lambda r: r.version.match_modulo_rtype(version) and r.version.rtype=='rc')

    if not rc:
        sys.stderr.write("Cannot find rc.\n")
        exit(1)


    if not confirm("Upgrade %s to %s. Are you sure (Y/n)?"%(rc.version,version),default=True):
        return False

    release = copy(rc)
    release.version = version

    repo.releases.append(release)
    repo.save()
    repo.record_release(release)


    ref = repo.current_gitref()

    if ref == "master":
        print "xpd data updated. Please commit to complete upgrade of rc."
        return True

    return False

def branch_candidates(repo):
    candidates = []
    latest = repo.latest_full_release()
    if latest:
        candidates.append(latest)
    latest_pre = repo.latest_pre_release()
    if latest_pre and (not latest or latest_pre > latest):
        candidates.append(latest_pre)
    return candidates

def xpd_create_release(repo, options, args):

    if repo.is_detached_head():
        sys.stderr.write("Cannot create release from detached head.\n")
        exit(1)

    if hasattr(options,'release_branch') and options.release_branch:
        create_branch = True
    else:
        create_branch = False

    if create_branch:
        candidates = branch_candidates(repo)
        if len(candidates) == 0:
            print "No candidates to branch from"
            exit(1)
        if len(candidates) == 1:
            base_release = candidates[0]
        else:
            print "Candidate releases to branch from:\n"
            for i in range(len(candidates)):
                print "   " + str(i) + ": " + str(candidates[i].version)
            print ""
            x = raw_input("Choose candidate [%d..%d]:"%(0,len(candidates)-1))
            try:
                base_release = candidates[int(x)]
            except:
                print "Invalid choice"
                exit(1)
    elif hasattr(options,'release_type') and options.release_type:
        rtype = options.release_type
    else:
        x = raw_input("Enter release type (a=alpha,b=beta,r=rc): ")
        if x in ['a','alpha']:
            rtype='alpha'
        elif x in ['b','beta']:
            rtype='beta'
        elif x in ['r','rc']:
            rtype='rc'
        elif x in ['release']:
            rtype='release'
        else:
            sys.stderr.write("Unknown release type\n")
            exit(1)

        if rtype in ['release','']:
            sys.stderr.write("Cannot create release directly - must upgrade an rc\n")
            exit(1)

    if create_branch:
        pass
    elif hasattr(options,'release_version') and options.release_version:
        version = Version(version_str=options.release_version)
    else:
        latest = repo.latest_full_release()
        if latest:
            print "Latest release: %s" % latest.version
            latest_version = latest.version
        else:
            print "There is no full release yet"
            latest_version = Version(0,0,0,0)

        print "    Next major: %s" % latest_version.major_increment()
        print "    Next minor: %s" % latest_version.minor_increment()
        print "    Next point: %s" % latest_version.point_increment()

        latest_pre = repo.latest_pre_release()
        if latest_pre and (not latest or latest_pre > latest):
            print "Latest pre-release: %s" % latest_pre.version

        x = raw_input("Enter version number: ")
        version = Version(version_str=x)



    if create_branch:
        version = base_release.version
        version.branch = options.release_branch
#        version.set_branch_rnumber(repo.releases)
    else:
        version.rtype = rtype
        version.set_rnumber(repo.releases)

    if not confirm("Create release %s. Are you sure (Y/n)?"%version,default=True):
        return False


    # Do some checks

    local_mod = False
    for r in repo.all_repos():
        if r.has_local_modifications():
            print "%s has local modifications" % r
            local_mod = True

    if local_mod:
        print "Cannot create release: uncommitted modifications"
        exit(1)

    current_ok = xpd_check_dep(repo, options, args, return_current_ok=True)

    if not current_ok:
        print "Cannot create release: dependencies not up to date"
        exit(1)


    xpd_check_info(repo, options, args)

    ok = xpd_check_infr(repo, options, args, return_ok = True)

    if not ok:
        print "Updates required to eclipse files/Makefiles."
        print "Update files (or commit automatic changes) and try again."
        return True

    release = Release()
    release.version = version

    # deps = []

    # for head_dep in repo.dependencies:
    #     dep = copy(head_dep)
    #     path = dep.get_local_path()
    #     dep.gitbranch = dep.repo.current_gitbranch()
    #     dep.githash = dep.repo.current_githash()
    #     dep.uri = dep.repo.uri()
    #     if dep.repo.current_release():
    #         dep.version_str = str(dep.repo.current_release().version)
    #     deps.append(dep)

    # release.dependencies = deps

    release.parenthash = repo.current_githash()

    repo.releases.append(release)

    print "Created release %s" % str(release.version)

    repo.save_and_commit_release(release)

    release.githash = repo.get_child_hash(release.parenthash)

    if confirm("Do you want to make a zipfile (Y/n)? ",default=True):
        xpd_make_zip(repo,options,[])

    return False



def do_exports(repo):
    for export in repo.exports:
        print "Exporting %s" % export
        call(["xmake","export"],cwd = os.path.join(repo.path,export))
    return repo.exports

def xpd_make_zip(repo, options, args):

    # Do some checks

    old_style = options.old_style

    if old_style:
        oldstyle_includes = get_current_modules(repo)
        for x in os.listdir(repo.path):
            if re.match('app_.*',x):
                oldstyle_includes.add(x)
        oldstyle_root = repo.name
    else:
        oldstyle_includes = []
        oldstyle_root = None

    alternate_name = False

    local_mod = False
    for r in repo.all_repos():
        if r.has_local_modifications():
            print "%s has local modifications" % r
            local_mod = True

    if local_mod and not options.force:
        print "Cannot make zip: uncommitted modifications"
        exit(1)

    current_ok = xpd_check_dep(repo, options, args, return_current_ok=True,
                                allow_updates=False)

    if not current_ok:
        print "warning: Current dependency versions do not match meta-data"
        alternate_name = True

    rel = repo.current_release()
    if rel:
        vstr = str(rel.version)
    else:
        vstr = repo.current_githash()

    if alternate_name:
        vstr = raw_input("Please give a name for this snapshot: ")

    if old_style:
        vstr += "_flat"

    name = repo.name + "_" + vstr

    print "Building repo"
    ret = call(["xmake","CONFIG=All","all"], cwd=repo.path, shell=True)
    ret = 0
    if ret != 0:
        print "Error building"
        exit(1)

    exports = []
    exports += do_exports(repo)
    for dep in repo.dependencies:
        exports += do_exports(dep.repo)


    fname = name + ".zip"
    print "Creating %s" % fname

    f = zipfile.ZipFile(fname,"w")

    zip_repo(repo, f, exports, old_style,oldstyle_includes,oldstyle_root,include_binaries=repo.include_binaries, force=options.force)
    for dep in repo.dependencies:
        zip_repo(dep.repo, f, exports, old_style,oldstyle_includes,oldstyle_root, force=options.force)

    info_string = "<zipinfo>\n"
    info_string += "   <main>%s</main>\n"%repo.name
    if not alternate_name:
        info_string += "   <version>%s</version>\n"%vstr
    info_string += "</zipinfo>"

    if not old_style:
        f.writestr('.zipinfo',info_string)

    f.close()

    return False

def find_files(path):
    fs = []
    for root, dirs, files in os.walk(path):
        for f in files:
            fs.append(os.path.relpath(os.path.join(root, f),path))

    return fs


def rmrf_dir(path):
    """
    Recursively delete everything under a subdir. Use with care
    """

    for root, dirs, files in os.walk(path, topdown=False):
        for f in files:
	    p = os.path.join(root,f)
	    os.chmod(p, os.stat(p)[ST_MODE] | S_IWRITE)
	    os.remove(p)
        for d in dirs:
	    p = os.path.join(root,d)
	    os.chmod(p, os.stat(p)[ST_MODE] | S_IWRITE)
	    os.rmdir(p)
    os.rmdir(path)

def zip_repo(repo, zipfile, exports, oldstyle=False, oldstyle_includes=[], oldstyle_root="",include_binaries=False, force = False):

    repo_copy_path = tempfile.mkdtemp()


    p = Popen(["git","clone",repo.path, repo_copy_path],
                         stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    p.communicate()

    call(["git","remote","set-url","origin",repo.uri()],cwd=repo_copy_path)

    p=Popen(["git","checkout",repo.current_githash()], cwd=repo_copy_path,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    p.communicate()

    if force:
        lines = find_files(repo_copy_path)
        try:
            f = open(os.path.join(repo_copy_path,".gitignore"))
            excludes = [x.strip() for x in f.readlines()]
            f.close()
        except:
            excludes = []
    else:
        process = Popen(["git","ls-files"],
                                   cwd=repo_copy_path,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        lines = process.stdout.readlines()
        excludes = []

    for f in lines:
        f = f.rstrip()
        if oldstyle:
            ok = False
            for i in oldstyle_includes:
                if os.path.commonprefix([f,i])==i:
                    ok = True
                    prefix = i
        else:
            ok = True

        for i in exports:
                if os.path.commonprefix([f,i])==i:
                    ok = False

        if re.match(".*\.git",f):
            ok = False

        for pattern in excludes:
            pattern = pattern.replace(".","\.")
            pattern = pattern.replace("*",".*")
            if re.match(pattern, f):
                ok = False

        if ok and f != "xpd.xml":
            if oldstyle:
                arcname = os.path.join(oldstyle_root, f)
            else:
                arcname = os.path.join(repo.name, f)

            if oldstyle and re.match('.*Makefile$',f):
                fh = open(os.path.join(repo_copy_path,f))
                lines = fh.readlines()
                for i in range(len(lines)):
                    lines[i] = lines[i].replace('xcommon/module_xcommon','module_xcommon')
                    lines[i] = lines[i].replace('../..','..')
                fh.close()
                new_makefile = ''.join(lines)
                zipfile.writestr(arcname, new_makefile)
            elif f == 'README.rst':
                lines = xpd_update_readme(repo,[],[],
                                          write_back=False,
                                          xmos_package = repo.is_xmos_repo(),
                                          use_current_version=True)
                new_readme = ''.join(lines)
                zipfile.writestr(arcname, new_readme)
            else:
                try:
                    zipfile.write(os.path.join(repo_copy_path, f), arcname=arcname)
                except:
                    pass

    for export in exports:
        export_path = os.path.join(repo.path,export)
        export_path = os.path.join(export_path, "export")
        for root, dirs, files in os.walk(export_path):
            for f in files:
                fullpath = os.path.join(root, f)
                arcname = os.path.relpath(fullpath, export_path)
                if oldstyle:
                    arcname = os.path.join(oldstyle_root, arcname)
                else:
                    arcname = os.path.join(repo.name, arcname)

                zipfile.write(fullpath,arcname=arcname)

    if not oldstyle and repo.git_export == True:
        print "exporting git"
        print repo
        for root, dirs, files in os.walk(os.path.join(repo_copy_path,".git")):
            for f in files:
                fullpath = os.path.join(root, f)
                arcname=os.path.join(repo.name,os.path.relpath(root, repo_copy_path))
                arcname=os.path.join(arcname, f)
                zipfile.write(fullpath,arcname=arcname)



    xpd_dom = repo.todom("xpd")

    if not repo.git_export:
        # Explicitly add version
        rootelem = xpd_dom.getElementsByTagName("xpd")[0]
        elem = xpd_dom.createElement("version")
        rel = repo.current_release()
        if rel:
            rel = str(rel.version)
        else:
            rel = str(repo.current_githash())
        text = xpd_dom.createTextNode(rel)
        elem.appendChild(text)
        rootelem.appendChild(elem)


    rootelem = xpd_dom.getElementsByTagName("xpd")[0]
    xpd_str = '<?xml version=\"1.0\" ?>\n' + xpd.xmlobject.pp_xml(xpd_dom, rootelem).strip()

    zipfile.writestr(os.path.join(repo.name,"xpd.xml"), xpd_str)

    if include_binaries:
        for root, dirs, files in os.walk(os.path.join(repo.path)):
            for f in files:
                if re.match('.*\.xe$',f):
                    fullpath = os.path.join(root, f)
                    arcname=os.path.relpath(root, repo.path)
                    if oldstyle:
                        arcname = os.path.join(oldstyle_root, arcname)
                    else:
                        arcname=os.path.join(repo.name,arcname)
                    arcname=os.path.join(arcname, f)
                    zipfile.write(fullpath,arcname=arcname)

    rmrf_dir(repo_copy_path)



def xpd_show(repo, options, args):

    rel = repo.current_release()
    if rel:
        version = str(rel.version)
    else:
        version = str(repo.current_githash())

    print "INFO:\n"
    print "              Name: %s" % repo.longname
    print "           Version: %s" % version
    print "              Icon: %s" % repo.icon
    print "          Location: %s" % repo.location
    #print "     Documentation: %s" % repo.doc
    print "       Description: %s" % repo.description
    if repo.git_export != None:
        print "   Export git info: %s" % repo.git_export

    print "\nDEPENDENCIES:\n"
    xpd_show_dep(repo, options, args)

    if repo.exports != []:
        print "\nEXPORTS:\n"
        for export in repo.exports:
            print "     %s" % export


def remove_indent(xs):
    return [re.match(' *(.*)',x).groups(0)[0] for x in xs]

def add_indent(n, xs):
    indent = ''.join([' ' for x in range(n)])
    return [indent + s for s in xs]

def rst_make_title(title, ch):
    underline = ''.join([ch for x in title])
    return [title,underline,'']




def xpd_update_readme(repo, options, args,
                      xmos_package=False, write_back=True,
                      use_current_version=False):

    f = open(os.path.join(repo.path,'README.rst'))
    lines = f.readlines()
    f.close()

    remove_items = ['Latest release','Stable release','Maintainer','Description','Status','Required packages']

    remove_sections = ['Required Modules','Required Repositories','Required software (dependencies)']
    if xmos_package:
        remove_sections += ['Support','Documentation']


    delete_until_next_section = False
    found_sections = 0
    first_section_index = None
    for i in range(len(lines)):
        line = lines[i]
        m = re.match(r':(.*): (.*)',line)
        if m:
            key = m.groups(0)[0]
            if key.upper() in [x.upper() for x in remove_items]:
                line = '-DELETED-\n'

        if xmos_package:
            if re.match(r'.*[D|d]ocumentation can be found.*',line):
                line = '-DELETED-\n'

        if i < len(lines)-1:
            m = re.match(r'[-=^.][-=^.]+',lines[i+1])
        else:
            m = None

        if m:
            found_sections += 1
            delete_until_next_section = False
            if line.strip().upper() in [x.upper() for x in remove_sections]:
                delete_until_next_section = True

        if not first_section_index and found_sections == 1:
            first_section_index = i

        if delete_until_next_section:
            line = '-DELETED-\n'

        lines[i] = line

    heading, lines = lines[:first_section_index+1],lines[first_section_index+1:]
    lines = [x for x in lines if x != '-DELETED-\n']

    new_header = "\n"

    vstr = None
    rel = repo.current_release()
    if rel:
        vstr = str(rel.version)
    else:
        vstr = repo.current_githash()

    if vstr and use_current_version:
        new_header += ":Version: %s\n" % vstr
    elif repo.latest_release():
        new_header += ":Latest release: %s\n" % repo.latest_release().version

    if xmos_package and repo.vendor:
        new_header += ":Vendor: %s\n" % repo.vendor
    if not xmos_package and repo.maintainer:
        new_header += ":Maintainer: %s\n" % repo.maintainer

    if repo.description:
        desc = repo.description.split('\n')
        new_header += ':Description: %s\n' % desc[0]
        for x in desc[1:]:
            new_header += '  %s' % x

    lines = heading + [x + '\n' for x in new_header.split('\n')] + lines

    lines += ['\n','Required software (dependencies)\n','================================\n','\n']

    if repo.dependencies == []:
        lines += ['  * None\n']
    else:
        for dep in repo.dependencies:
            if dep.repo.name == 'xcommon':
                lines += ['  * xcommon (if using develpoment tools earlier than 11.11.0)\n']
            else:
                if xmos_package or not dep.uri:
                    lines += ['  * %s\n'%dep.repo.name]
                else:
                    lines += ['  * %s (%s)\n'%(dep.repo.name,dep.uri)]
    lines += ['\n']


    if xmos_package:
        if repo.docnum:
            lines += ['Documentation\n','=============\n','\n',
                      '  You can find the latest documentation for this software at:\n'
                      '\n',
                      '      http://www.xmos.com/docnum/X%s\n'%repo.docnum,'\n']

        support = """Support
=======

  This package is support by XMOS Ltd. Issues can be raised against the software
  at:

      http://www.xmos.com/support
"""

        lines += [x+'\n' for x in support.split('\n')]

    for i in range(len(lines)-1):
        if lines[i] == '\n' and lines[i+1] == '\n':
            lines[i] = '-DELETED-\n'

    lines = [x for x in lines if x != '-DELETED-\n']

    #for line in lines:
    #        sys.stdout.write(line)

    if not write_back:
        return lines
    else:
        f=open(os.path.join(repo.path,"README.rst"),"w")
        for line in lines:
            f.write(line)
        f.close()
    return False

def xpd_gen_readme(repo, options, args):

    sep = '.. seperator'
    latest = repo.latest_release(release_filter=lambda r: r.version.rtype=='rc')
    if latest:
        full_version = latest.version
        full_version.rtype=''
    header = ['.. class:: announce instapaper_body rst wikistyle readme.rst','']

    header.extend(rst_make_title(repo.longname,'.'))

    if repo.description:
        header.extend(remove_indent(repo.description.split('\n')) + [''])

    if repo.scope:
        header.extend([':Scope: %s'%repo.scope,''])

    if repo.vendor:
        header.extend([':Vendor: %s'%repo.vendor,''])

    if repo.maintainer:
        header.extend([':Maintainer: %s'%repo.maintainer,''])

    if latest:
        header.extend([':Cur. Release: %(ver)s'%{'ver':full_version},''])

    if repo.keywords and repo.keywords != []:
        keywords_str = ', '.join(repo.keywords)
        header.extend([':Keywords: %s'%keywords_str,''])

    release_details = []
    if latest:
        release_title = 'Current Release: %s' % full_version

        release_details.extend(rst_make_title(release_title,'='))
        release_details.extend([':RC: %d'%latest.version.rnumber,'',sep,''])

        rnotes = repo.get_release_notes(full_version)

        if not rnotes:
            notes = 'No release notes'
        else:
            notes = rnotes.wholeText

        release_details.extend([':Release Notes:',''])
        release_details.extend(add_indent(1,remove_indent(notes.split('\n')) + ['']))
        release_details.extend([sep,''])
        ## use cases

        for uc in repo.usecases:
            if uc.usecase_type == 'invalid':
                release_details.extend([':Invalid:',''])
            else:
                release_details.extend([':Use Case:',''])

            usecase_details = []
            usecase_title = '**'+uc.name
            if uc.usecase_type == 'general':
                usecase_title += " - Suitable for general purpose usage"
            elif uc.usecase_type == 'development':
                usecase_title += " - Suitable for development usage"
            usecase_title += '**'
            usecase_details.append(usecase_title)
            usecase_details.append('')

            if uc.toolchain and uc.toolchain.tools and uc.toolchain.tools != []:
                usecase_details.extend(['** Compatible Tools **',''])
                usecase_details.extend([', '.join(uc.toolchain.tools),''])

            if uc.devices and uc.devices.devices and uc.devices.devices != []:
                usecase_details.extend(['** Compatible Devices **',''])
                usecase_details.extend([', '.join(uc.devices.devices),''])

            release_details.extend(add_indent(4,usecase_details))





    changelog = []

    if repo.changelog != []:
        changelog = rst_make_title('Release History','=')

        for x in sorted(repo.changelog):
            changelog.extend([':%s:'%x.version_str,''])

            log = x.wholeText.rstrip().split('\n')

            changelog.extend(log+[''])



    print '\n'.join(header)
    print '\n'.join(release_details)
    print '\n'.join(changelog)


def xpd_checkout(repo, options, args):
    if len(args) < 1:
        return False

    local_mod = False
    for dep in repo.dependencies:
        if dep.repo.has_local_modifications():
            print "%s has local modifications" % dep.repo_name
            local_mod = True

    if local_mod:
        exit(1)

    try:
        version = Version(version_str=args[0])
    except:
        xpd_dep_iter(repo, "git checkout %s" % args[0])
        return False

    rel = repo.get_release(version)
    githash = repo.get_child_hash(rel.parenthash)
    vrepo = repo.get_versioned_repo(version)

    vrepo.checkout(githash)
    for dep in vrepo.dependencies:
        dep.repo.checkout(dep.githash)


def xpd_check_info(repo, options, args,check_icon=True):
    update = False
    if repo.description==None or repo.description=="":
        print "The repo's description is one or two paragraphs description the contents of the repository."
        if confirm("No description found. Add one (Y/n)?",default=True):
            print "Enter paragraph description:\n"
            repo.description = raw_input()
            update = True

    if check_icon and repo.icon==None:
        print "The repo's icon is a path relative to the repository pointing to a 16x16 png icon representing the repository."
        if confirm("No icon found. Add one (Y/n)?",default=True):
            print "Enter path to icon: "
            repo.icon = raw_input()
            update = True

    if False and repo.doc==None:
        if confirm("No documentation uri found. Add one (Y/n)?",default=True):
            print "Enter documentation uri: "
            repo.doc = raw_input()
            update = True

    if repo.vendor==None:
        print "If this repository is maintained by a organization or company that will package, release and support the code then the vendor field should be set with the organization's name."
        if confirm("No vendor found. Add one (Y/n)?",default=True):
            print "Enter vendor name: "
            repo.vendor = raw_input()
            update = True

    if repo.maintainer==None:
        print "The repository's maintainer is a person who is reponsible for the repository. All repos should have a maintainer."
        if confirm("No maintainer found. Add one (Y/n)?",default=True):
            print "Enter maintainer github username: "
            repo.maintainer = raw_input()
            update = True

    if repo.scope==None:
        print "The repository's scope says whether the repository is a prototype or example code or a maintained product."
        if confirm("No project type/scope found. Add one (Y/n)?",default=True):
            print "Enter scope (prototype, example, product or reference design): "
            repo.scope = raw_input()
            update = True

    if repo.docnum==None:
        print "If this is an XMOS package, there may be an associated four digit document number for the repository."
        if confirm("No document number found. Add one (Y/n)?",default=True):
            print "Enter document number: "
            repo.docnum = raw_input()
            update = True



    return update

def xpd_tag(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("error: requires version number\n")
        exit(1)

    v = Version(version_str=args[0])

    rel = repo.get_release(v)

    relhash = repo.get_child_hash(rel.parenthash)

    if not relhash:
        sys.stderr.write("error: cannot determine release hash\n")
        exit(1)

    call(["git","tag","v%s"%str(v),relhash],cwd=Repo.path)

    print "Tagged"

def xpd_create_app(repo, options, args):
    if len(args) < 1:
        appname = repo.name
        m = re.match(r'(sc_|proj_|sw_)(.*)', appname)
        if m:
            appname = m.groups(0)[1]
        appname = 'app_' + appname + '_example'
        sys.stdout.write('Enter application name (%s): '%appname)
        x = raw_input()
        if x != '':
            appname = x

    else:
        appname = args[0]
        if appname[:4] != 'app_':
            appname = 'app_' + appname

    print "Creating %s." % appname
    os.mkdir(os.path.join(repo.path,appname))
    os.mkdir(os.path.join(repo.path,appname,'src'))
    os.mkdir(os.path.join(repo.path,appname,'docs'))
    os.mkdir(os.path.join(repo.path,appname,'docs','src'))
    f = open(os.path.join(repo.path,appname,'Makefile'),'w')
    f.write(templates.app_makefile)
    f.close()
    return False

def xpd_create_module(repo, options, args):
    if len(args) < 1:
        modulename = repo.name
        m = re.match(r'(sc_|proj_|sw_)(.*)', modulename)
        if m:
            modulename = m.groups(0)[1]
        modulename = 'module_' + modulename
        sys.stdout.write('Enter module name (%s): '%modulename)
        x = raw_input()
        if x != '':
            modulename = x
    else:
        modulename = args[0]
        if modulename[:4] != 'module_':
            modulename = 'module_' + modulename

    print "Creating %s." % modulename
    os.mkdir(os.path.join(repo.path,modulename))
    os.mkdir(os.path.join(repo.path,modulename,'src'))
    f = open(os.path.join(repo.path,modulename,'module_build_info'),'w')
    f.write(templates.module_build_info)
    f.close()
    return False


def xpd_init(repo, options, args):
    xpd_check_info(repo, options, args,check_icon=False)

    apps = [x for x in os.listdir(repo.path) if x[0:4] == 'app_']

    if apps == []:
        print """
Usually a repository contains at least one application that people can build
to an executable. Even if the repository is primarily a component repository
containing code modules for other projects it is usual to include a sample or
test application within the repo.
"""

        if confirm("Would you like to create an application within this project (Y/n)?",default=True):
            xpd_create_app(repo, options, [])

    modules = [x for x in os.listdir(repo.path) if x[0:7] == 'module_']

    if modules == []:
        print """
A repository can contains modules that contain sets of source files than can be re-used across applications.
"""

        if confirm("Would you like to create an module within this project (Y/n)?",default=True):
            xpd_create_module(repo, options, [])

    if not os.path.exists(os.path.join(repo.path,'Makefile')):
        f = open(os.path.join(repo.path,'Makefile'),'w')
        f.write(templates.toplevel_makefile)
        f.close()

    if not os.path.exists(os.path.join(repo.path,'docs')):
        os.mkdir(os.path.join(repo.path,'docs'))
        os.mkdir(os.path.join(repo.path,'docs','src'))

    if not os.path.exists(os.path.join(repo.path,'LICENSE.txt')):
        if confirm("Would you like to license the code in this repository under the XCore Open Source License (Y/n)?",default=True):
            holder = ''
            while holder == '':
                sys.stdout.write('Enter copyright holder: ')
                holder = raw_input()
            f = open(os.path.join(repo.path,'LICENSE.txt'),'w')
            f.write(templates.xcore_license % {'holder':holder})
            f.close()

    if not os.path.exists(os.path.join(repo.path,'.project')):
        project_lines = templates.dotproject.split('\n')
        f = open(os.path.join(repo.path,'.project'),'w')
        for line in project_lines:
            line = line.replace('%PROJECT%',repo.name)
            f.write(line+'\n')
        f.close()

    if not os.path.exists(os.path.join(repo.path,'.cproject')):
        configs = ['Debug','Release']
        xpd.check_project.create_cproject(repo, configs)

    if not os.path.exists(os.path.join(repo.path,'README.rst')):
        maintainer = repo.maintainer
        if not maintainer or maintainer=='':
            maintainer = '<github username of maintainer>'
        longname = repo.longname
        if not longname or longname=='':
            longname = '<title>'
        desc = repo.description
        if not desc or desc=='':
            desc = 'A brief description of the repo'
        f = open(os.path.join(repo.path,'README.rst'),'w')
        context = {'maintainer':maintainer,
                   'longname':longname,
                   'description':desc}
        f.write(templates.readme % context)
        f.close()

    xpd_check_dep(repo, options, args)

    return True

def xpd_check_infr(repo, options, args, return_ok=False):
    ok = True
    project_ok = xpd.check_project.check_project(repo)
    ok = ok and project_ok
    cproject_ok = xpd.check_project.check_cproject(repo)
    ok = ok and cproject_ok
    makefiles_ok = xpd.check_project.check_makefiles(repo)
    ok = ok and makefiles_ok
    doc_ok = xpd.check_project.check_docdir(repo)
    ok = ok and doc_ok
    if return_ok:
        return ok
    else:
        return False

commands = [("init","Initialize the xpd meta-information file"),
            ("check_dep","Check dependencies of the current repository"),
            ("add_dep","Add dependency"),
            ("remove_dep","Remove dependency"),
            ("create_release","Create a release"),
            ("upgrade_rc","Upgrade an RC to a final release"),
            ("list","List releases"),
            ("show","Show current state"),
            ("checkout","Checkout release"),
            ("make_zip","Make zipfile of release"),
            ("check_info","Check related information"),
            ("tag","Tag the repo with a version"),
            ("check_infr","Check infrastructure (Makefiles, eclipse projects)"),
            ("create_app","Create application within project"),
            ("update_readme","Update README.rst with latest metainformation"),
            ("create_module","Create module within project")]

if __name__ == "__main__":
    usage = "usage: %prog command [options]"
    usage += "\n\nAvailable commands:\n\n"
    for c in commands:
        usage += "%20s: %s"%(c[0],c[1])

        usage += "\n"

    optparser = OptionParser(usage=usage)

    optparser.add_option("-r","--release-version",dest="release_version",
                         help="release version")

    optparser.add_option("-t","--release-type",dest="release_type",
                         help="release type: release, alpha, beta or rc")

    optparser.add_option("-b","--branch",dest="release_branch",
                         help="release branch name")

    optparser.add_option("--oldstyle",dest="old_style",action="store_true",default=False,
                         help="create an old style zip")

    optparser.add_option("--force",dest="force",action="store_true",default=False,
                         help="Ignore safety check")



    if len(sys.argv) > 1 and sys.argv[1] == 'git':
        repo = Repo(".")
        xpd_dep_iter(repo, ' '.join(sys.argv[1:]))
        exit(0)

    (options, args) = optparser.parse_args()



    if len(args) < 1:
        optparser.error("incorrect number of arguments")


    repo = Repo(".")

    command = args[0]

    if command == "help":
        optparser.print_help()
        exit(0)

    args = args[1:]

    if command in [c[0] for c in commands]:
        command_fn = eval("xpd_%s" % command)
        if command_fn(repo, options, args):
            repo.save()
    else:
        matches = difflib.get_close_matches(command, commands)
        sys.stderr.write("Unknown command %s.\n" % command)
        if matches != []:
            sys.stderr.write("Did you mean one of:\n")
            for m in matches:
                sys.stderr.write("   %s\n" % m)

