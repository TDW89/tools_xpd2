#!/usr/bin/python
from stat import ST_MODE
from stat import S_IWRITE

from optparse import OptionParser
import os, subprocess, sys, re
import difflib
import zipfile
import tempfile
import shutil
from copy import copy
from xpd.xpd_data import Repo, Release, Version, Dependency
from xpd.xpd_data import AllSoftwareDescriptor, SoftwareDescriptor
import xpd.check_project
from xpd.xpd_subprocess import call, Popen
import xpd.xmlobject
from xpd import templates
from xpd import cognidox
from xpd.docholder import DocumentHolder, DHSection, DHDocumentLink
import xdoc
import xmossphinx
import xmos_xref

ALLOWED_SCOPES=["Roadmap","Example","Early Development","General Use"]

xdoc = None
xmossphinx = None
xmos_xref = None

rst_title_regexp = r'[-=^~.][-=^~.]+'

def samefile(fileA, fileB):
    try:
        return os.path.samefile(fileA, fileB)
    except AttributeError:
        return os.path.abspath(fileA).lower() == os.path.abspath(fileB).lower()


def confirm(msg, default=False):
    x = raw_input(msg)
    if (x in ["n","N","no","No","NO"]):
        return False
    if (x in ["y","Y","yes","Yes","YES"]):
        return True
    return default


def xpd_dep_iter(repo, command, output_repo_names=True):
    deps = repo.dependencies
    os.system(command)
    for dep in deps:
        cwd = os.getcwd()
        os.chdir(dep.get_local_path())
        if output_repo_names:
            sys.stdout.write("\n"+str(dep)+":\n")
        os.system(command)
        os.chdir(cwd)

def xpd_show_dep(repo, options, args):

    if repo.dependencies == []:
        print "No dependencies"
    else:
        print "Actual:"
        for dep in repo.dependencies:
            if dep.repo:
                rel = dep.repo.current_release()
                if dep.repo.has_local_modifications():
                    local_mod = "(local modifications)"
                else:
                    local_mod = ""
                if rel:
                    print "%20s: %s %s"%(dep.repo, rel.version, local_mod)
                else:
                    print "%20s: %s %s"%(dep.repo, dep.repo.current_githash(),local_mod)

        print "\nExpected:"
        for dep in repo.dependencies:
            if dep.version_str:
                print "%20s: %s"%(dep.repo_name, dep.version_str)
            else:
                print "%20s: %s"%(dep.repo_name, dep.githash)



def xpd_remove_dep(repo, options, args):
    if len(args) < 1:
        return False
    to_remove = args[0]
    deps = repo.dependencies

    for d in deps:
        if d.repo_name == to_remove:
            deps.remove(d)
            print "Removed"
            return True

    sys.stderr.write("%s is not a current dependency\n" % to_remove)
    return False


def get_current_modules(repo):
    makefiles = []
    for root, dirs, files in os.walk(repo.path, topdown=False):
        for f in files:
            if re.match(root,'.*\.source.*'):
                continue
            if re.match(root,'.*\.doxygen.*'):
                continue
            if f=="Makefile":
                makefiles.append(os.path.join(root,f))

    modules = set([])
    for path in makefiles:
        f = open(path)
        while True:
            line = f.readline()
            if line=="":
                break
            m = re.match(r'\s*USED_MODULES\s*\+?=(.*)', line)
            if m:
                s = m.groups(0)[0]
                ms = [m for m in s.split(' ') if m != '']
                modules = modules | set(ms)
        f.close()

    return modules

def find_current_dependencies(repo):
    modules = get_current_modules(repo)

    root_dir = os.path.join(repo.path,"..")

    repos = set([])
    for dep_repo in os.listdir(root_dir):
        repo_path = os.path.join(root_dir,dep_repo)
        if os.path.isdir(repo_path):
            for module_dir in os.listdir(repo_path):
                if os.path.isdir(os.path.join(repo_path,module_dir)):
                    if module_dir in modules:
                        modules.remove(module_dir)
                        if not samefile(repo_path, repo.path):
                            repos.add(dep_repo)

    if len(modules) != 0:
        print "WARNING: Can't find repos for the following modules:"
        for m in modules:
            print "   " + m

    return repos

def xpd_add_dep(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("ERROR: required repo name")
        sys.exit(1)

    for dep in repo.dependencies:
        if dep.repo_name == args[0]:
            sys.stderr.write("ERROR: dependency already exists")
            sys.exit(1)


    dep = Dependency(parent=repo)
    dep.repo_name = args[0]
    dep.repo = Repo(dep.get_local_path())
    dep.uri = dep.repo.uri()
    dep.githash = dep.repo.current_githash()
    rel = dep.repo.current_release()
    if rel:
        dep.version_str = str(rel.version)
    repo.dependencies.append(dep)
    print "Added"
    return True


def xpd_check_dep(repo, options, args, return_current_ok=False,
                   allow_updates=True, force_changes = True):
    deps = [d.repo_name for d in repo.dependencies]

    current_ok = True
    repos = find_current_dependencies(repo)

    repos = repos - set(deps)
    update = False
    for dep_repo in repos:

        if allow_updates and \
           (force_changes or confirm("Add %s to dependencies (Y/n)?"%dep_repo,default=True)):
            dep = Dependency(parent=repo)
            dep.repo_name = dep_repo
            dep.repo = Repo(dep.get_local_path())
            dep.uri = dep.repo.uri()
            dep.githash = dep.repo.current_githash()
            rel = dep.repo.current_release()
            if rel:
                dep.version_str = str(rel.version)
            repo.dependencies.append(dep)
            print "Added"
            update = True
        else:
            if not allow_updates:
                print "Dependency %s is not up to date" % dep_repo
            if dep_repo != "xcommon":
                current_ok = False

    for dep in [d for d in repo.dependencies if d.repo]:
        rel = dep.repo.current_release()
        if dep.githash != dep.repo.current_githash() or \
           (rel and dep.version_str != str(rel.version)):
            if allow_updates and \
                    (force_changes or confirm("%s has new local version. Update metainformation (Y/n)?"%dep.repo_name,default=True)):
                dep.githash = dep.repo.current_githash()
                if rel:
                    dep.version_str = str(rel.version)
                else:
                    dep.version_str = None
                update = True
            else:
                if not allow_updates:
                    print "Dependency %s is not up to date" % dep.repo_name
                current_ok = False


    if len(repos) == 0 and current_ok and not update:
        print "Dependencies OK"

    if return_current_ok:
        return current_ok
    else:
        return update


def xpd_list(repo, options, args):
    rels = repo.releases
    rels.sort()
    rels.reverse()
    for rel in rels:
        if rel.virtual == "True":
            print "%s (unknown git location)" % str(rel.version)
        else:
            print rel.version

def xpd_upgrade_rc(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("Requires version number.\n")
        sys.exit(1)

    version = Version(version_str=args[0])

    version.rtype = ''
    version.rnumber = 0

    if repo.get_release(version):
        sys.stderr.write("Version already exists.\n")
        sys.exit(1)


    rc = repo.latest_release(release_filter=lambda r: r.version.match_modulo_rtype(version) and r.version.rtype=='rc')

    if not rc:
        sys.stderr.write("Cannot find rc.\n")
        sys.exit(1)


    if not confirm("Upgrade %s to %s. Are you sure (Y/n)?"%(rc.version,version),default=True):
        return False

    release = copy(rc)
    release.version = version

    repo.releases.append(release)
    repo.save()
    repo.record_release(release)


    ref = repo.current_gitref()

    if ref == "master":
        print "xpd data updated. Please commit to complete upgrade of rc."
        return True

    return False

def branch_candidates(repo):
    candidates = []
    latest = repo.latest_full_release()
    if latest:
        candidates.append(latest)
    latest_pre = repo.latest_pre_release()
    if latest_pre and (not latest or latest_pre > latest):
        candidates.append(latest_pre)
    return candidates

def xpd_build_sw(repo, options):
    print "Building repo"
    if options.nobuild:
        return
    ret = call(["xmake","CONFIG=All","NO_IGNORE_ERRORS=1","all"], cwd=repo.path, shell=True)
    if ret != 0 and not options.force:
        print "Error building"
        sys.exit(1)


def xpd_create_release(repo, options, args):

    if repo.is_detached_head():
        sys.stderr.write("Cannot create release from detached head.\n")
        sys.exit(1)

    if hasattr(options,'release_branch') and options.release_branch:
        create_branch = True
    else:
        create_branch = False

    if create_branch:
        candidates = branch_candidates(repo)
        if len(candidates) == 0:
            print "No candidates to branch from"
            sys.exit(1)
        if len(candidates) == 1:
            base_release = candidates[0]
        else:
            print "Candidate releases to branch from:\n"
            for i in range(len(candidates)):
                print "   " + str(i) + ": " + str(candidates[i].version)
            print ""
            x = raw_input("Choose candidate [%d..%d]:"%(0,len(candidates)-1))
            try:
                base_release = candidates[int(x)]
            except:
                print "Invalid choice"
                sys.exit(1)
    elif hasattr(options,'release_type') and options.release_type:
        rtype = options.release_type
    else:
        x = raw_input("Enter release type (a=alpha,b=beta,r=rc): ")
        if x in ['a','alpha']:
            rtype='alpha'
        elif x in ['b','beta']:
            rtype='beta'
        elif x in ['r','rc']:
            rtype='rc'
        elif x in ['release']:
            rtype='release'
        else:
            sys.stderr.write("Unknown release type\n")
            sys.exit(1)

        if rtype in ['release','']:
            sys.stderr.write("Cannot create release directly - must upgrade an rc\n")
            sys.exit(1)

    if create_branch:
        pass
    elif hasattr(options,'release_version') and options.release_version:
        version = Version(version_str=options.release_version)
    else:
        latest = repo.latest_full_release()
        if latest:
            print "Latest release: %s" % latest.version
            latest_version = latest.version
        else:
            print "There is no full release yet"
            latest_version = Version(0,0,0,0)

        print "    Next major: %s" % latest_version.major_increment()
        print "    Next minor: %s" % latest_version.minor_increment()
        print "    Next point: %s" % latest_version.point_increment()

        latest_pre = repo.latest_pre_release()
        if latest_pre and (not latest or latest_pre > latest):
            print "Latest pre-release: %s" % latest_pre.version

        x = raw_input("Enter version number: ")
        version = Version(version_str=x)



    if create_branch:
        version = base_release.version
        version.branch = options.release_branch
#        version.set_branch_rnumber(repo.releases)
    else:
        version.rtype = rtype
        version.set_rnumber(repo.releases)

    if not confirm("Create release %s. Are you sure (Y/n)?"%version,default=True):
        return False


    # Do some checks

    local_mod = False
    for r in repo.all_repos():
        if r.has_local_modifications():
            print "%s has local modifications" % r
            local_mod = True

    if local_mod and not options.force:
        print "Cannot create release: uncommitted modifications"
        sys.exit(1)

    current_ok = xpd_check_dep(repo, options, args, return_current_ok=True)

    if not current_ok:
        print "Cannot create release: dependencies not up to date"
        sys.exit(1)


    xpd_check_info(repo, options, args)

    notes = xpd_parse_release_notes(repo, options, args, return_notes = True)

    fstr = version.final_version_str()
    if not fstr in notes:
        print "Cannot find release notes for %s, please update CHANGELOG.rst" % fstr
        return True
    else:
        print "RELEASE NOTES FOR %s:" % fstr
        print "----"
        for item in notes[fstr]:
            print item
            print "----"
        if not confirm("Are these notes up to date? (Y/n)", default=True):
            print "Please update notes and try again"
            return True

    ok = xpd.check_project.check_makefiles(repo)

    if not ok:
        print "Updates required to Makefiles."
        print "Update files (or commit automatic changes) and try again."
        return True

    print "Creating sandbox and checking build"
    repo.move_to_temp_sandbox()
    xpd_build_sw(repo, options)
    xpd_build_results(repo,options,['all'])
    repo.delete_temp_sandbox()

    release = Release()
    release.version = version

    # deps = []

    # for head_dep in repo.dependencies:
    #     dep = copy(head_dep)
    #     path = dep.get_local_path()
    #     dep.gitbranch = dep.repo.current_gitbranch()
    #     dep.githash = dep.repo.current_githash()
    #     dep.uri = dep.repo.uri()
    #     if dep.repo.current_release():
    #         dep.version_str = str(dep.repo.current_release().version)
    #     deps.append(dep)

    # release.dependencies = deps

    release.parenthash = repo.current_githash()

    repo.releases.append(release)

    print "Created release %s" % str(release.version)

    if confirm("Do you want to update the README.rst file (Y/n)?",
               default=True):
        xpd_update_readme(repo,options,[])
        call(["git","add","README.rst"],
             cwd=repo.path,
             stdout=subprocess.PIPE,
             stderr=subprocess.PIPE)

    repo.save_and_commit_release(release)

    release.githash = repo.get_child_hash(release.parenthash)

    if confirm("Do you want to make a zipfile (Y/n)? ",default=True):
        xpd_make_zip(repo,options,[])

    repo.delete_temp_sandbox()

    return False



def do_exports(repo):
    for export in repo.exports:
        print "Exporting %s" % export
        call(["xmake","export"],cwd = os.path.join(repo.path,export))
    return repo.exports

def xpd_make_zip(repo, options, args):

    # Do some checks

    old_style = options.old_style

    if old_style:
        oldstyle_includes = get_current_modules(repo)
        for x in os.listdir(repo.path):
            if re.match('app_.*',x):
                oldstyle_includes.add(x)
        oldstyle_root = repo.name
    else:
        oldstyle_includes = []
        oldstyle_root = None

    alternate_name = False

    local_mod = False
    for r in repo.all_repos():
        if r.has_local_modifications():
            print "%s has local modifications" % r
            local_mod = True

    if local_mod and not options.force:
        print "Cannot make zip: uncommitted modifications"
        sys.exit(1)

    current_ok = xpd_check_dep(repo, options, args, return_current_ok=True,
                                allow_updates=False)

    if not current_ok:
        print "warning: Current dependency versions do not match meta-data"
        alternate_name = True

    rel = repo.current_release()
    if rel:
        vstr = str(rel.version)
    else:
        vstr = repo.current_githash()

    if alternate_name:
        vstr = raw_input("Please give a name for this snapshot: ")

    if old_style:
        vstr += "_flat"

    name = repo.name + "_" + vstr

    update = False
    if options.upload:
        update = xpd_check_partinfo(repo, options, args)

    print "Creating temporary sandbox"
    repo.move_to_temp_sandbox()

    if repo.include_binaries:
        xpd_build_sw(repo, options)

    if not options.nobuild:
        print "Creating build result info"
        xpd_build_results(repo, options, ["all"])

    xpd.check_project.check_project(repo, force_creation=True)
    xpd.check_project.check_cproject(repo, force_creation=True)
    for dep in repo.dependencies:
        xpd.check_project.check_project(dep.repo, force_creation=True)
        xpd.check_project.check_cproject(dep.repo, force_creation=True)

    print "Building docs"
    xpd_build_docs(repo, options)

    exports = []
    exports += do_exports(repo)
    for dep in repo.dependencies:
        exports += do_exports(dep.repo)

    fname = name + ".zip"
    print "Creating %s" % fname

    f = zipfile.ZipFile(fname,"w")

    zip_repo(repo, f, exports, old_style,oldstyle_includes,oldstyle_root,include_binaries=repo.include_binaries, force=options.force)
    for dep in repo.dependencies:
        zip_repo(dep.repo, f, exports, old_style,oldstyle_includes,oldstyle_root, force=options.force, no_app_projects=True)


    if not options.nodocs:
        for docdir in repo.docdirs:
            insert_doc(repo.name, os.path.join(repo.path,docdir), f, is_xmos_repo = repo.is_xmos_repo(),
                   repo=repo)

        for block in repo.components:
            src = os.path.join(repo.path,block.path,'_build','text','README.txt')
            arcname = os.path.join(repo.name, block.path, 'README.txt')
            f.write(src, arcname = arcname)

        if repo and xpd.check_project.flat_projects:
            (dotproject, xproject) = xpd.check_project.create_doc_project(repo)
            f.writestr(os.path.join(repo.name,'doc','.project'),dotproject)
            f.writestr(os.path.join(repo.name,'doc','.xproject'),xproject)



        insert_topdoc(repo,f)

        xref = xmos_xref.XRefInfo('xpd')

        for dep in repo.dependencies:
            if dep.repo.subpartnumber and dep.repo.is_xmos_repo():
                version = dep.repo.current_version_or_githash()
                print "Trying to find version %s of %s in cognidox" % (version, dep.repo.name)
                m = re.match('(.*)(rc|beta|alpha)\d*$',version)
                if m:
                    version = m.groups(0)[0]
                cogfile = cognidox.fetch_version(dep.repo.subpartnumber, version)

                if cogfile:
                    tmpfile = tempfile.TemporaryFile()
                    tmpfile.write(cogfile.read())
                    insert_dep_docs_to_zip(f, tmpfile, dep.repo.name)
                    for docdir in dep.repo.docdirs:
                        docdir = os.path.join(dep.repo.path,docdir)
                        docinfo = xref.get_or_create_docinfo_from_dir(docdir,
                                                                      topdir = dep.repo.name)
                        swlink = docinfo.get_swlink(repo.partnumber)
                        base = os.path.basename(docdir)
                        if base == 'doc':
                            base = dep.repo.name
                        swlink.path = '%s/doc/%s' % (dep.repo.name,base)
                        swlink.version = repo.current_version_or_githash()
                        swlink.subversion = dep.repo.current_version_or_githash()
                        swlink.title = repo.longname
                        swlink.repo_name = dep.repo.name
                        swlink.primary = "False"
                        swlink.subpartnumber = dep.repo.subpartnumber

                    cogfile.close()
                    tmpfile.close()
                else:
                    print "WARNING: Cannot find relevant version of %s is cognidox. DEPENDENCIES SHOULD BE OFF RELEASED VERSIONS OF COMPONENTS" % dep.repo.name


    info_string = "<zipinfo>\n"
    info_string += "   <main>%s</main>\n"%repo.name
    if not alternate_name:
        info_string += "   <version>%s</version>\n"%vstr
    info_string += "</zipinfo>"

    if not old_style:
        f.writestr('.zipinfo',info_string)

    f.close()
    print "Created %s" % fname

    if options.upload:
        print "Uploading zip file"
        m = re.match('(.*)rc(\d+)$',vstr)
        if m:
            zip_vstr = m.groups(0)[0]
        else:
            zip_vstr = vstr
        cognidox.doCognidoxCheckIn(repo.subpartnumber,
                                   fname,
                                   version = zip_vstr,
                                   draft=False)
        print "Creating document holder"
        xpd_make_docholder(repo, options, args, to_file = ".docholder.xml")
        print "Uploading document holder"
        cognidox.doCognidoxCheckIn(repo.partnumber,
                                   ".docholder.xml",
                                   version = vstr,
                                   draft=True)




    return update

def find_files(path):
    fs = []
    for root, dirs, files in os.walk(path):
        for f in files:
            fs.append(os.path.relpath(os.path.join(root, f),path))

    return fs


def zip_repo(repo, zipfile, exports, oldstyle=False, oldstyle_includes=[], oldstyle_root="",include_binaries=False, force = False, no_app_projects = False):


    lines = find_files(repo.path)
    excludes = []


    for docdir in repo.docdirs:
        excludes.append(docdir+'/*')

    excludes.append('toplevel_doc/*')
    excludes.append('*_build/*')
    excludes.append('*app_description')
    excludes.append('*module_description')
    excludes.append('*README.rst')
    excludes.append('.zipinfo')
    if xpd.check_project.flat_projects:
        excludes.append('.cproject')
        excludes.append('.project')


    for f in lines:
        f = f.rstrip()
        if oldstyle:
            ok = False
            for i in oldstyle_includes:
                if os.path.commonprefix([f,i])==i:
                    ok = True
                    prefix = i
        else:
            ok = True


        for i in exports:
            if not re.match('.*\.project$|.*\.cproject|.*\.xproject$',f):
                if os.path.commonprefix([f,i])==i:
                    ok = False

        if re.match(".*\.git",f):
            ok = False


        for pattern in excludes:
            pattern = pattern.replace(".","\.")
            pattern = pattern.replace("*",".*")
            pattern = pattern + "$"
            if re.match(pattern, f):
                ok = False

        if no_app_projects:
            if re.match('.*\.project$|.*\.cproject|.*\.xproject$',f) and \
               re.match('.*app_.*',f):
               ok = False

        if ok and f != "xpd.xml":
            if oldstyle:
                arcname = os.path.join(oldstyle_root, f)
            else:
                arcname = os.path.join(repo.name, f)

            if oldstyle and re.match('.*Makefile$',f):
                fh = open(os.path.join(repo.path,f))
                lines = fh.readlines()
                for i in range(len(lines)):
                    lines[i] = lines[i].replace('xcommon/module_xcommon','module_xcommon')
                    lines[i] = lines[i].replace('../..','..')
                fh.close()
                new_makefile = ''.join(lines)
                zipfile.writestr(arcname, new_makefile)
            elif re.match('.*Makefile$',f):
                if os.path.exists(os.path.join(repo.path,f)):
                    fh = open(os.path.join(repo.path,f))
                    makefile_str = fh.read()
                    fh.close()
                    makefile_str = xpd.check_project.patch_makefile(makefile_str)
                    zipfile.writestr(arcname,makefile_str)
            elif f == 'README.rst':
                lines = xpd_update_readme(repo,[],[],
                                          write_back=False,
                                          xmos_package = repo.is_xmos_repo(),
                                          use_current_version=True)
                new_readme = ''.join(lines)
                zipfile.writestr(arcname, new_readme)
            else:
                try:
                    zipfile.write(os.path.join(repo.path, f), arcname=arcname)
                except:
                    pass

    for export in exports:
        export_path = os.path.join(repo.path,export)
        export_path = os.path.join(export_path, "export")
        for root, dirs, files in os.walk(export_path):
            for f in files:
                fullpath = os.path.join(root, f)
                arcname = os.path.relpath(fullpath, export_path)
                if oldstyle:
                    arcname = os.path.join(oldstyle_root, arcname)
                else:
                    arcname = os.path.join(repo.name, arcname)

                zipfile.write(fullpath,arcname=arcname)

    if not oldstyle and repo.git_export == True:
        print "exporting git"
        print repo
        for root, dirs, files in os.walk(os.path.join(repo.path,".git")):
            for f in files:
                fullpath = os.path.join(root, f)
                arcname=os.path.join(repo.name,os.path.relpath(root, repo.path))
                arcname=os.path.join(arcname, f)
                zipfile.write(fullpath,arcname=arcname)


    if repo.partnumber and repo.current_release():
        publishinfo = \
"""<publishinfo>
    <partnum>%s</partnum>
    <version>%s</version>
</publishinfo>
""" % (repo.partnumber,str(repo.current_release().version))
        zipfile.writestr(os.path.join(repo.name,".publishinfo"), publishinfo)

    xpd_dom = repo.todom("xpd")

    if not repo.git_export:
        # Explicitly add version
        rootelem = xpd_dom.getElementsByTagName("xpd")[0]
        elem = xpd_dom.createElement("version")
        rel = repo.current_release()
        if rel:
            rel = str(rel.version)
        else:
            rel = str(repo.current_githash())
        text = xpd_dom.createTextNode(rel)
        elem.appendChild(text)
        rootelem.appendChild(elem)


    rootelem = xpd_dom.getElementsByTagName("xpd")[0]
    xpd_str = '<?xml version=\"1.0\" ?>\n' + xpd.xmlobject.pp_xml(xpd_dom, rootelem).strip()

    zipfile.writestr(os.path.join(repo.name,"xpd.xml"), xpd_str)

    if include_binaries:
        for root, dirs, files in os.walk(os.path.join(repo.path)):
            for f in files:
                if re.match('.*\.xe$',f):
                    fullpath = os.path.join(root, f)
                    arcname=os.path.relpath(root, repo.path)
                    if oldstyle:
                        arcname = os.path.join(oldstyle_root, arcname)
                    else:
                        arcname=os.path.join(repo.name,arcname)
                    arcname=os.path.join(arcname, f)
                    zipfile.write(fullpath,arcname=arcname)


def insert_dep_docs_to_zip(main_zipfile, sub_zipfile, repo_name):
    print "Extracting docs from %s zipfile" % repo_name
    dep_zip = zipfile.ZipFile(sub_zipfile,mode='r')
    for name in dep_zip.namelist():
        m = re.match('%s/doc/.*'%repo_name,name)
        if m or name == '%s/README.html'%repo_name:
            zfile = dep_zip.open(name)
            s = zfile.read()
            zfile.close()
            main_zipfile.writestr(name,s)
    dep_zip.close()

def insert_topdoc(repo,zipfile):
    if repo.is_xmos_repo():
        htmlpath='xdehtml'
    else:
        htmlpath='html'

    htmlpath = os.path.join(repo.topdoc_path,'_build',htmlpath)
    zipdocpath = os.path.join(repo.name, 'doc')
    fs = find_files(htmlpath)
    for f in fs:
        if not re.match('sphinx.output|\.doctree.*|objects.inv|.buildinfo',f):
            src = os.path.join(htmlpath, f)
            dst = os.path.join(zipdocpath, f)
            dst = dst.replace('_static','.static')
            if re.match('[^/]*.html',f):
                index_str = open(src).read()
                index_str = index_str.replace('_static','.static')
                if f == 'index.html':
                    rel = repo.current_release()
                    if repo.is_xmos_repo() and repo.subpartnumber and rel:
                        xde_comment = '\n<!--XDE partnum="%s" version="%s"-->\n'%(repo.subpartnumber,str(rel.version))
                        index_str = index_str.replace('<html','%s<html'%xde_comment)

                zipfile.writestr(dst,index_str)

                readme = ''.join(open(src).readlines())
                readme = readme.replace('"_static','"doc/.static')
                readme = readme.replace('"././','"doc/')
                if f == 'index.html':
                    zipfile.writestr(os.path.join(repo.name,'README.html'),
                                     readme)
                else:
                    zipfile.writestr(os.path.join(repo.name,f),
                                     readme)
            else:
                zipfile.write(src,arcname=dst)



def insert_doc(repo_name, path, zipfile,base = None,insert_pdf = True,
               is_xmos_repo=True, repo=None):
    import_xdoc()
    print path
    config = xdoc.get_config(path)
    pdfname = config['SPHINX_MASTER_DOC']+'.pdf'

    pdfpath = os.path.join(path,'_build','xlatex',pdfname)
    if not base:
        base = os.path.basename(path)
        if base == 'doc':
            base = repo_name

    if base == '':
        arcpdfname = repo_name + '.pdf'
    else:
        arcpdfname = base + '.pdf'
    zipdocpath = os.path.join(repo_name, 'doc',base)
    if insert_pdf:
        zipfile.write(pdfpath,arcname=os.path.join(repo_name,'doc',arcpdfname))
    if is_xmos_repo:
        htmlpath=os.path.join(path,'_build','xdehtml')
    else:
        htmlpath=os.path.join(path,'_build','html')


    fs = find_files(htmlpath)

    for f in fs:
        if not re.match('sphinx.output|\.doctree.*|.buildinfo|objects.inv',f):
            src = os.path.join(htmlpath, f)
            dst = os.path.join(zipdocpath, f)
            x = open(src)
            src_str = x.read()
            x.close()
            src_str = src_str.replace('_static','.static')
            dst = dst.replace('_static','.static')
            zipfile.writestr(dst, src_str)

def xpd_status(repo, options, args):
    xpd_show(repo, options, args)

def xpd_info(repo, options, args):
    xpd_show(repo, options, args)

def xpd_show(repo, options, args):

    rel = repo.current_release()
    if rel:
        version = str(rel.version)
    else:
        version = str(repo.current_githash())

    print "INFO:\n"
    print "              Name: %s" % repo.longname
    print "           Version: %s" % version
    print "          Location: %s" % repo.location
    print "       Description: %s" % repo.description
    if repo.git_export != None:
        print "   Export git info: %s" % repo.git_export

    if repo.docdirs != []:
        print "     Documentation: %s" % repo.docdirs[0]
        for doc in repo.docdirs[1:]:
            print "                    %s" % doc

    print "\nSOFTWARE BLOCKS\n"

    print "Apps:\n"

    def print_software_block_details(swblock):
        print swblock.name
        if not swblock.has_readme():
            print "***** WARNING - missing README.rst ******"
        print "       Name: %s" % swblock.name
        print "      Scope: %s" % swblock.scope
        print "Description: %s" % swblock.description
        print "   Keywords: %s" % ','.join(swblock.keywords)
        print "  Published: %s" % swblock.is_published()
        print ""

    for app in repo.get_apps():
        print_software_block_details(app)

    print "\nModules:\n"

    for module in repo.get_modules():
        print_software_block_details(module)


    print "\nDEPENDENCIES:\n"
    xpd_show_dep(repo, options, args)

    if repo.exports != []:
        print "\nEXPORTS:\n"
        for export in repo.exports:
            print "     %s" % export


def remove_indent(xs):
    return [re.match(' *(.*)',x).groups(0)[0] for x in xs]

def add_indent(n, xs):
    indent = ''.join([' ' for x in range(n)])
    return [indent + s for s in xs]

def rst_make_title(title, ch):
    underline = ''.join([ch for x in title])
    return [title,underline,'']




def xpd_update_readme(repo, options, args,
                      xmos_package=False, write_back=True,
                      use_current_version=False,
                      doclinks = False):

    f = open(os.path.join(repo.path,'README.rst'))
    lines = f.readlines()
    f.close()

    remove_items = ['Latest release','Stable release','Maintainer','Description','Status','Required packages']

    remove_sections = ['Required Modules','Required Repositories','Required software (dependencies)']
    if xmos_package:
        remove_sections += ['Support','Documentation']


    delete_until_next_section = False
    found_sections = 0
    section_indices = {}
    for i in range(len(lines)):
        line = lines[i]

        if xmos_package:
            line = line.replace('XCORE.com','XMOS')

        m = re.match(r':(.*): (.*)',line)
        if m:
            key = m.groups(0)[0]
            if key.upper() in [x.upper() for x in remove_items]:
                line = '-DELETED-\n'

        if xmos_package:
            if re.match(r'.*[D|d]ocumentation can be found.*',line):
                line = '-DELETED-\n'

        if i < len(lines)-1:
            m = re.match(rst_title_regexp,lines[i+1])
        else:
            m = None

        if m:
            found_sections += 1
            delete_until_next_section = False
            if line.strip().upper() in [x.upper() for x in remove_sections]:
                delete_until_next_section = True
            section_indices[found_sections] = i+1

        if delete_until_next_section:
            line = '-DELETED-\n'

        lines[i] = line

    heading, prologue, lines = \
        lines[:section_indices[1]+1],\
        lines[section_indices[1]+1:section_indices[2]-1],\
        lines[section_indices[2]-1:]
    lines = [x for x in lines if x != '-DELETED-\n']


    new_header = "\n"

    vstr = None
    rel = repo.current_release()
    if rel:
        vstr = str(rel.version)
    else:
        vstr = repo.current_githash()

    if vstr and use_current_version:
        new_header += ":Version: %s\n" % vstr
    elif repo.latest_release():
        new_header += ":Latest release: %s\n" % repo.latest_release().version

    if xmos_package and repo.vendor:
        new_header += ":Vendor: %s\n" % repo.vendor
    if not xmos_package and repo.maintainer:
        new_header += ":Maintainer: %s\n" % repo.maintainer

    if repo.description:
        desc = repo.description.split('\n')
        new_header += ':Description: %s\n' % desc[0]
        for x in desc[1:]:
            new_header += '  %s' % x


    lines += ['\n','Required software (dependencies)\n','================================\n','\n']

    if repo.dependencies == []:
        lines += ['  * None\n']
    else:
        for dep in repo.dependencies:
            if dep.repo.name == 'xcommon':
                lines += ['  * xcommon (if using development tools earlier than 11.11.0)\n']
            else:
                if xmos_package or not dep.uri:
                    lines += ['  * %s\n'%dep.repo.name]
                else:
                    lines += ['  * %s (%s)\n'%(dep.repo.name,dep.uri)]
    lines += ['\n']

    doc_header = ''
    if xmos_package:
        if repo.docdirs != []:
            if doclinks:
                import_xdoc()
                doc_header += '\n\nSoftware Blocks\n===============\n\n\n'
                components = sorted(repo.components,key=lambda x:x.id)
                for comp in components:
                    doc_header += '%s (%s)\n %s\n'%(comp.name,comp.id,comp.description)

                doc_header += '\n\nDocumentation\n===============\n\n\n'
                for docdir in repo.docdirs:
                    title = xdoc.get_title(os.path.join(repo.path,docdir))
                    base = os.path.basename(docdir)
                    if base == 'doc':
                        base = repo.name
                    doc_header += '  * `%s <././%s/index.html>`_' % (title,base)
                    doc_header += ' `PDF <././%s.pdf>`_ \n' % (base)

                doc_header += '  * `Release Notes <././changelog.html>`_\n'
                doc_header += '\n\n'
            else:
                lines += ['Documentation\n','=============\n','\n',
                          'You can find the documentation for this software in the doc/ directory of the package.\n\n']

        support = """Support
=======

  This package is support by XMOS Ltd. Issues can be raised against the software
  at:

      http://www.xmos.com/support
"""

        lines += [x+'\n' for x in support.split('\n')]

    new_header = [x + '\n' for x in new_header.split('\n')]
    doc_header = [x + '\n' for x in doc_header.split('\n')]

    lines = heading + new_header + prologue + doc_header+ lines


    for i in range(len(lines)-1):
        if lines[i] == '\n' and lines[i+1] == '\n':
            lines[i] = '-DELETED-\n'

    lines = [x for x in lines if x != '-DELETED-\n']

    #for line in lines:
    #        sys.stdout.write(line)

    if not write_back:
        return lines
    else:
        f=open(os.path.join(repo.path,"README.rst"),"w")
        for line in lines:
            f.write(line)
        f.close()
    return False

def check_swblock(repo, options, args, comp):
   print comp.id
   print "   Name: %s" % comp.name
   print "   Type: %s" % comp.type
   print ""

   if not comp.has_readme():
       print "  ERROR: software block %s has no README.rst" % comp.path
       valid = False
       print "  Creating new template README"
       f = open(comp.readme_path(),"w")
       f.write(templates.swblock_readme)
       f.close()
       repo.git_add(comp.readme_path())
   else:
       if comp.name=='' or comp.name[0] == '<':
           print "  ERROR: software block title not specified, update README.rst"
           valid = False
       if comp.description[0]=='<' or re.match('Software Block:',comp.description):
           print "  ERROR: software block description not specified, update README.rst"
           valid = False

       if comp.scope not in ALLOWED_SCOPES:
           print "  ERROR: inavlid scope"
           print "  Update README to set scope to one of:"
           for scope in ALLOWED_SCOPES:
               print "         " + scope
           print ""
           valid = False

       if not comp.metainfo_path and comp.scope != "Example":
           print "  ERROR: software block without metainfo must have scope 'Example'"
           valid = False


       if comp.keywords_text and comp.keywords_text[0]=='<':
           print "  ERROR: keywords field as template, update README.rst to specify keywords or delete the line"
           valid = False

       if comp.boards_text and comp.boards_text[0]=='<':
           print "  ERROR: boards field as template, update README.rst to specify keywords or delete the line"
           valid = False


def xpd_check_swblocks(repo, options, args, return_valid = False):
    valid = True
    def find(f,xs):
        for x in xs:
            if f(x):
                return x
    current_blocks = repo.components
    actual_blocks = repo.get_software_blocks()
    for comp in repo.components:
        if not find(lambda x: x.id == comp.id, actual_blocks):
            print "Removing old swblock: " + comp.id

    repo.components = actual_blocks

    for comp in repo.components:
        check_swblock(repo,options,args,comp)



    if return_valid:
        return valid

    return True


def xpd_gen_readme(repo, options, args):

    sep = '.. seperator'
    latest = repo.latest_release(release_filter=lambda r: r.version.rtype=='rc')
    if latest:
        full_version = latest.version
        full_version.rtype=''
    header = ['.. class:: announce instapaper_body rst wikistyle readme.rst','']

    header.extend(rst_make_title(repo.longname,'.'))

    if repo.description:
        header.extend(remove_indent(repo.description.split('\n')) + [''])

    if repo.vendor:
        header.extend([':Vendor: %s'%repo.vendor,''])

    if repo.maintainer:
        header.extend([':Maintainer: %s'%repo.maintainer,''])

    if latest:
        header.extend([':Cur. Release: %(ver)s'%{'ver':full_version},''])

    if repo.keywords and repo.keywords != []:
        keywords_str = ', '.join(repo.keywords)
        header.extend([':Keywords: %s'%keywords_str,''])

    release_details = []
    if latest:
        release_title = 'Current Release: %s' % full_version

        release_details.extend(rst_make_title(release_title,'='))
        release_details.extend([':RC: %d'%latest.version.rnumber,'',sep,''])

        rnotes = repo.get_release_notes(full_version)

        if not rnotes:
            notes = 'No release notes'
        else:
            notes = rnotes.wholeText

        release_details.extend([':Release Notes:',''])
        release_details.extend(add_indent(1,remove_indent(notes.split('\n')) + ['']))
        release_details.extend([sep,''])
        ## use cases

        for uc in repo.usecases:
            if uc.usecase_type == 'invalid':
                release_details.extend([':Invalid:',''])
            else:
                release_details.extend([':Use Case:',''])

            usecase_details = []
            usecase_title = '**'+uc.name
            if uc.usecase_type == 'general':
                usecase_title += " - Suitable for general purpose usage"
            elif uc.usecase_type == 'development':
                usecase_title += " - Suitable for development usage"
            usecase_title += '**'
            usecase_details.append(usecase_title)
            usecase_details.append('')

            if uc.toolchain and uc.toolchain.tools and uc.toolchain.tools != []:
                usecase_details.extend(['** Compatible Tools **',''])
                usecase_details.extend([', '.join(uc.toolchain.tools),''])

            if uc.devices and uc.devices.devices and uc.devices.devices != []:
                usecase_details.extend(['** Compatible Devices **',''])
                usecase_details.extend([', '.join(uc.devices.devices),''])

            release_details.extend(add_indent(4,usecase_details))





    changelog = []

    if repo.changelog != []:
        changelog = rst_make_title('Release History','=')

        for x in sorted(repo.changelog):
            changelog.extend([':%s:'%x.version_str,''])

            log = x.wholeText.rstrip().split('\n')

            changelog.extend(log+[''])



    print '\n'.join(header)
    print '\n'.join(release_details)
    print '\n'.join(changelog)


def xpd_checkout(repo, options, args):
    if len(args) < 1:
        return False

    local_mod = False
    for dep in repo.dependencies:
        if dep.repo.has_local_modifications():
            print "%s has local modifications" % dep.repo_name
            local_mod = True

    if local_mod:
        sys.exit(1)

    if args[0] == 'latest':
        rel = repo.latest_release()
        if not rel:
            print "Cannot find latest release"
            sys.exit(1)
        else:
            print "Checking out %s" % str(rel.version)
            version=rel.version
    else:
        try:
            version = Version(version_str=args[0])
        except:
            xpd_dep_iter(repo, "git checkout %s" % args[0])
            return False

    rel = repo.get_release(version)
    githash = repo.get_child_hash(rel.parenthash)
    if not githash:
        print >>sys.stderr, "ERROR: cannot find githash for version %s, maybe the git history has been modified" % str(version)
        sys.exit(1)
    vrepo = repo.get_versioned_repo(version)

    vrepo.checkout(githash)
    for dep in vrepo.dependencies:
        dep.repo.checkout(dep.githash)


def xpd_check_info(repo, options, args,check_icon=True):
    update = False
    if repo.description==None or repo.description=="":
        print "The repo's description is one or two paragraphs description the contents of the repository."
        if confirm("No description found. Add one (Y/n)?",default=True):
            print "Enter paragraph description:\n"
            repo.description = raw_input()
            update = True

    if False and check_icon and repo.icon==None:
        print "The repo's icon is a path relative to the repository pointing to a 16x16 png icon representing the repository."
        if confirm("No icon found. Add one (Y/n)?",default=True):
            print "Enter path to icon: "
            repo.icon = raw_input()
            update = True

    if False and repo.docdirs==[]:
        if confirm("No documentation path found. Add one (Y/n)?",default=True):
            print "Enter documentation path: "
            docdir = raw_input()
            repo.docdirs.append(docdir)
            update = True

    if repo.vendor==None:
        print "If this repository is maintained by a organization or company that will package, release and support the code then the vendor field should be set with the organization's name."
        if confirm("No vendor found. Add one (Y/n)?",default=True):
            print "Enter vendor name: "
            repo.vendor = raw_input()
            update = True

    if repo.maintainer==None:
        print "The repository's maintainer is a person who is reponsible for the repository. All repos should have a maintainer."
        if confirm("No maintainer found. Add one (Y/n)?",default=True):
            print "Enter maintainer github username: "
            repo.maintainer = raw_input()
            update = True


    update_partinfo = xpd_check_partinfo(repo, options, args)
    update = update or update_partinfo

    return update

def xpd_tag(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("error: requires version number\n")
        sys.exit(1)

    v = Version(version_str=args[0])

    rel = repo.get_release(v)

    relhash = repo.get_child_hash(rel.parenthash)

    if not relhash:
        sys.stderr.write("error: cannot determine release hash\n")
        sys.exit(1)

    call(["git","tag","v%s"%str(v),relhash],cwd=Repo.path)

    print "Tagged"

def xpd_create_app(repo, options, args):
    if len(args) < 1:
        appname = repo.name
        m = re.match(r'(sc_|proj_|sw_)(.*)', appname)
        if m:
            appname = m.groups(0)[1]
        appname = 'app_' + appname + '_example'
        sys.stdout.write('Enter application name (%s): '%appname)
        x = raw_input()
        if x != '':
            appname = x

    else:
        appname = args[0]
        if appname[:4] != 'app_':
            appname = 'app_' + appname

    print "Creating %s." % appname
    os.mkdir(os.path.join(repo.path,appname))
    os.mkdir(os.path.join(repo.path,appname,'src'))
    os.mkdir(os.path.join(repo.path,appname,'docs'))
    os.mkdir(os.path.join(repo.path,appname,'docs','src'))
    f = open(os.path.join(repo.path,appname,'Makefile'),'w')
    f.write(templates.app_makefile)
    f.close()
    return False

def xpd_create_module(repo, options, args):
    if len(args) < 1:
        modulename = repo.name
        m = re.match(r'(sc_|proj_|sw_)(.*)', modulename)
        if m:
            modulename = m.groups(0)[1]
        modulename = 'module_' + modulename
        sys.stdout.write('Enter module name (%s): '%modulename)
        x = raw_input()
        if x != '':
            modulename = x
    else:
        modulename = args[0]
        if modulename[:4] != 'module_':
            modulename = 'module_' + modulename

    print "Creating %s." % modulename
    os.mkdir(os.path.join(repo.path,modulename))
    os.mkdir(os.path.join(repo.path,modulename,'src'))
    f = open(os.path.join(repo.path,modulename,'module_build_info'),'w')
    f.write(templates.module_build_info)
    f.close()
    return False


def xpd_init(repo, options, args):
    xpd_check_info(repo, options, args,check_icon=False)

    apps = [x for x in os.listdir(repo.path) if x[0:4] == 'app_']

    if apps == []:
        print """
Usually a repository contains at least one application that people can build
to an executable. Even if the repository is primarily a component repository
containing code modules for other projects it is usual to include a sample or
test application within the repo.
"""

        if confirm("Would you like to create an application within this project (Y/n)?",default=True):
            xpd_create_app(repo, options, [])

    modules = [x for x in os.listdir(repo.path) if x[0:7] == 'module_']

    if modules == []:
        print """
A repository can contains modules that contain sets of source files than can be re-used across applications.
"""

        if confirm("Would you like to create an module within this project (Y/n)?",default=True):
            xpd_create_module(repo, options, [])

    if not os.path.exists(os.path.join(repo.path,'Makefile')):
        f = open(os.path.join(repo.path,'Makefile'),'w')
        f.write(templates.toplevel_makefile)
        f.close()

    if not os.path.exists(os.path.join(repo.path,'docs')):
        os.mkdir(os.path.join(repo.path,'docs'))
        os.mkdir(os.path.join(repo.path,'docs','src'))

    if not os.path.exists(os.path.join(repo.path,'LICENSE.txt')):
        if confirm("Would you like to license the code in this repository under the XCore Open Source License (Y/n)?",default=True):
            holder = ''
            while holder == '':
                sys.stdout.write('Enter copyright holder: ')
                holder = raw_input()
            f = open(os.path.join(repo.path,'LICENSE.txt'),'w')
            f.write(templates.xcore_license % {'holder':holder})
            f.close()

    if not os.path.exists(os.path.join(repo.path,'.project')):
        project_lines = templates.dotproject.split('\n')
        f = open(os.path.join(repo.path,'.project'),'w')
        for line in project_lines:
            line = line.replace('%PROJECT%',repo.name)
            f.write(line+'\n')
        f.close()

    if not os.path.exists(os.path.join(repo.path,'.cproject')):
        configs = ['Debug','Release']
        xpd.check_project.create_cproject(repo, configs)

    if not os.path.exists(os.path.join(repo.path,'README.rst')):
        maintainer = repo.maintainer
        if not maintainer or maintainer=='':
            maintainer = '<github username of maintainer>'
        longname = repo.longname
        if not longname or longname=='':
            longname = '<title>'
        desc = repo.description
        if not desc or desc=='':
            desc = 'A brief description of the repo'
        f = open(os.path.join(repo.path,'README.rst'),'w')
        context = {'maintainer':maintainer,
                   'longname':longname,
                   'description':desc}
        f.write(templates.readme % context)
        f.close()

    xpd_check_dep(repo, options, args)

    return True

def xpd_check_infr(repo, options, args, return_ok=False):
    ok = True
    project_ok = xpd.check_project.check_project(repo, force_creation = True)
    ok = ok and project_ok
    cproject_ok = xpd.check_project.check_cproject(repo, force_creation = True)
    ok = ok and cproject_ok
    makefiles_ok = xpd.check_project.check_makefiles(repo, force_creation = True)
    ok = ok and makefiles_ok
    if return_ok:
        return ok
    else:
        return False

def xpd_check_makefiles(repo, options, args, return_ok=False):
    ok = xpd.check_project.check_makefiles(repo)
    if return_ok:
        return ok
    else:
        return False

def xpd_check_partinfo(repo, options, args):
    update = False
    if not repo.partnumber:
        print "If this is an XMOS package, there should be an associated part number for the repository."
        if confirm("No part number found. Add one (Y/n)?",default=True):
            repo.partnumber = \
                cognidox.query_and_create_document('/Projects/Apps',
                                                   default_title=repo.longname,
                                                   doctype='DH',
                                                   auto_create=True)
            repo.subpartnumber = \
                cognidox.query_and_create_document('/Projects/Apps',
                                                   default_title=repo.name+".zip",
                                                   doctype='SM',
                                                   auto_create=True)
            update = True
    # if not repo.partnumber:
    #     print "Cannot find a partnumber. If using cognidox, this should be the partnumber for the document holder *not* the zipfile itself. If a partnumber exists for the zipfile but not the document holder then please create a new partnumber"
    #     repo.partnumber = \
    #         cognidox.query_and_create_document('/Projects/Apps',
    #                                            default_title=repo.longname,
    #                                            doctype='DH')
    #     update = True
    # if not repo.subpartnumber:
    #     print "Need to create document for actual zipfile of software"
    #     repo.subpartnumber = \
    #         cognidox.query_and_create_document('/Projects/Apps',
    #                                            default_title=repo.name+".zip",
    #                                            doctype='SM')
    #     update = True
    print "Main part number = %s" % repo.partnumber
    print "Zipfile part number = %s" % repo.subpartnumber
    return update

def xpd_make_docholder(repo, options, args, to_file = None):
    import_xdoc()
    dh = DocumentHolder()
    if repo.tools:
        toolstr = ','.join(repo.tools)
    else:
        toolstr = ''
    dh.introduction= """
h3. Description

%s

""" % (repo.description)
    zip_section = DHSection()
    zip_link = DHDocumentLink()
    zip_section.title = "Software Zip"
    zip_section.description = "The zip containing the software"
    zip_link.partnum = repo.subpartnumber
    zip_link.issue = "%s" % cognidox.get_latest_issue(repo.subpartnumber)
    zip_section.documents.append(zip_link)
    dh.sections.append(zip_section)

    doc_section = DHSection()
    doc_section.title = "Related Documents"
    xref = xmos_xref.XRefInfo('xpd')
    include_doc_section = False
    for docdir in repo.docdirs:
        docinfo = xref.get_or_create_docinfo_from_dir(docdir)
        if docinfo.partnum:
            include_doc_section = True
            doc_link = DHDocumentLink()
            doc_link.partnum = docinfo.partnum
            doc_link.issue = "%s" % cognidox.get_latest_issue(docinfo.partnum)
            doc_section.documents.append(doc_link)

    readme_section = DHSection()
    readme_section.title = "README Documents"
    include_readme_section = False
    for comp in repo.components:
        docinfo = xref.get_or_create_docinfo_from_dir(comp.path)
        if docinfo.partnum:
            include_readme_section = True
            doc_link = DHDocumentLink()
            doc_link.partnum = docinfo.partnum
            doc_link.issue = "%s" % cognidox.get_latest_issue(docinfo.partnum)
            readme_section.documents.append(doc_link)


    if include_doc_section:
        dh.sections.append(doc_section)

    if include_readme_section:
        dh.sections.append(readme_section)

    if to_file:
        f = open(to_file,"w")
        f.write(dh.toxml("documentHolder"))
        f.close()
        return

    print dh.toxml("documentHolder")
    return False

def import_xdoc():
    global xdoc, xmossphinx, xmos_xref
    sys.path.append(os.path.abspath(os.path.join('..','xdoc')))
    sys.path.append(os.path.abspath(os.path.join('..','infr_docs')))
    sys.path.append(os.path.abspath(os.path.join('..','infr_docs','xmossphinx')))
    sys.path.append(os.path.abspath(os.path.join('..','infr_docs','xmossphinx','builders')))
#    try:
    xdoc = __import__("xdoc")
    xmossphinx = __import__("xmossphinx")
    xmos_xref = __import__("xmos_xref")
#    except ImportError:
    #    sys.stderr.write("Cannot find xdoc")
     #   sys.exit(1)

def xpd_build_dep_docs(dep):
    pass

def xpd_build_topdoc(repo,options=None,args=None):
    doc_path = repo.path
    readme = xpd_update_readme(repo,[],[],
                               write_back=False,
                               xmos_package = repo.is_xmos_repo(),
                               use_current_version=True,
                               doclinks = True)
    readme += [
        '.. toctree::\n',
        '   :hidden:\n',
        '\n'
        '   changelog\n']
    import_xdoc()

    topdoc_path = os.path.join(doc_path,'toplevel_doc')
    if os.path.exists(topdoc_path):
        shutil.rmtree(topdoc_path)
    os.makedirs(topdoc_path)
    f = open(os.path.join(topdoc_path,'index.rst'),'w')
    f.write(''.join(readme))
    f.close()
    changelog_path = os.path.join(repo.path,'CHANGELOG.rst')
    if os.path.exists(changelog_path):
        shutil.copy(changelog_path,os.path.join(topdoc_path,'changelog.rst'))
    if repo.is_xmos_repo():
        xdoc.main('xdehtml',path=topdoc_path,
                  config={'XDEHTML_UNPAGED_OUTPUT':'1'})
    else:
        xdoc.main('html',path=topdoc_path)
    print "Top level document created in %s" % topdoc_path

    repo.topdoc_path = topdoc_path

def xpd_build_docs(repo, options=None, args=None, buildlatex=True):
    if options.nodocs:
        return
    import_xdoc()
    if repo.is_xmos_repo():
        xref = xmos_xref.XRefInfo('xpd')
    docdirs = repo.docdirs
    rstonlysuffix = '.__rstonlythisone__'

    for swblock in repo.components:
        docdir = os.path.join(repo.path,swblock.path)
        curdir = os.path.abspath(os.curdir)
        os.chdir(docdir)
        xdoc_config = {}
        xdoc_config['SOURCE_SUFFIX'] = rstonlysuffix
        xdoc_config['ALT_TITLE'] = "%s README" % swblock.id
        xdoc_config['FORCE_UPLOAD'] = '1'
        xdoc_config['AUTO_CREATE'] = "1"

        readme = os.path.join(docdir,'README.rst')
        shutil.copy(readme,readme.replace('.rst',rstonlysuffix))

        if repo.is_xmos_repo():
            xdoc.main('text', config=xdoc_config)
            if options and options.upload:
                xdoc.main('issue', config=xdoc_config)
                docinfo = xref.get_or_create_docinfo_from_dir(docdir)
                swblock.docPartNumber = docinfo.partnum
                swblock.docVersion = 'latest'
            else:
                xdoc.main('xdehtml', config=xdoc_config)
        else:
            xdoc.main('html')
            if buildlatex:
                xdoc.main('pdf')

        readme = os.path.join(docdir,'README.rst')
        os.remove(readme.replace('.rst',rstonlysuffix))
        os.chdir(curdir)

    for docdir in docdirs:

        docdir = os.path.join(repo.path,docdir)
        curdir = os.path.abspath(os.curdir)
        os.chdir(docdir)

        xdoc_config = {}
        xdoc_config['AUTO_CREATE'] = "1"

        if repo.is_xmos_repo():
            if options and options.upload:
                xdoc.main('issue', config=xdoc_config)
            else:
                xdoc.main('xdehtml', config=xdoc_config)
                if buildlatex:
                    xdoc.main('xmospdf', config=xdoc_config)
        else:
            xdoc.main('html')
            if buildlatex:
                xdoc.main('pdf')
        os.chdir(curdir)

        if repo.is_xmos_repo() and repo.partnumber:
            print "Adding link from document to software package"
            docinfo = xref.get_or_create_docinfo_from_dir(docdir, topdir = repo.name)
            swlink = docinfo.get_swlink(repo.partnumber)

            base = os.path.basename(docdir)
            if base == 'doc':
                base = repo.name

            swlink.path = '%s/doc/%s' % (repo.name,base)
            swlink.version = repo.current_version_or_githash()
            swlink.title = repo.longname
            swlink.repo_name = repo.name
            swlink.primary = "True"
            swlink.subpartnumber = repo.subpartnumber

    xpd_build_topdoc(repo)
    if repo.is_xmos_repo():
        xref.update()
    return False

def xpd_check_all(repo, options, args):
    ok = True
    if not (options.nocheckdep):
        res = xpd_check_dep(repo, options,args,return_current_ok=True)
        ok = ok and res
        if res:
            print "DEPENDENCIES OK"
    res = xpd_check_info(repo, options, args)
    if not res:
        print "METAINFORMATION OK"
    ok = ok and not res
    res = xpd_check_swblocks(repo, options, args, return_valid = True)
    if res:
        print "SWBLOCK INFORMATION OK"
    ok = ok and res
    res = xpd_check_infr(repo, options, args, return_ok = True)
    if res:
        print "MAKEFILE/ECLIPSE PROJECT INFORMATION OK"
    ok = ok and res
    if not ok:
        print ""
        print "================================================================="
        print "ERRORS/REPOSITORY UPDATED"
        print "================================================================="
        print "Either there are errors in your repository structure or the"
        print "repository structure/meta-information has been updated (see previous output for details"
        print "Try 'git status' and 'git diff' to see changes that have been made to repository"
        print "================================================================="
    return True

def xpd_update(repo, options, args):
    return xpd_check_all(repo, options, args)

def xpd_create_warnings(repo, options, args, return_warnings = False):
    warnings = []
    rel = repo.current_release()
    if not rel:
        warnings.append("Repository is not at a specified version")
    for dep in repo.dependencies:
        if dep.repo.name == 'xcommon':
            continue
        print "Checking dependency %s" % dep.repo.name
        rel = dep.repo.current_release()
        if not rel:
            warning = "Dependency '%s' is not on a specified version"%dep.repo.name
            warnings.append(warning)
        elif not dep.repo.partnumber:
            warning = "Dependency '%s' is not a published component"%dep.repo.name
            warnings.append(warning)

    if not return_warnings:
        print "WARNINGS\n========\n\n"
        for warning in warnings:
            print warning
        return False
    else:
        return warnings


def xpd_parse_release_notes(repo, options, args, return_notes = False):
    changelog_path = os.path.join(repo.path,'CHANGELOG.rst')
    if not os.path.exists(changelog_path):
        print >>sys.stderr, "ERROR: cannot find CHANGELOG.rst"
        sys.exit(1)
    f = open(changelog_path)
    lines = f.readlines()
    f.close()
    item = ''
    new_item = False
    current_version = None
    notes = {}
    for i in range(len(lines)):
        line = lines[i]
        if i < len(lines)-1:
            next = lines[i+1]
        else:
            next = ''

        if re.match(rst_title_regexp,line):
            continue

        try:
            v = Version(version_str=line.strip())
        except xpd.xpd_data.VersionParseError:
            v = None

        if v:
            if current_version:
                items.append(item.strip())
                notes[str(current_version)] = items
#                print "VERSION: %s" % str(current_version)
#                print items
            current_version = v
            new_item = True
            items = []
            item = ''
            line = ''

        m = re.match('\s*[-*] (.*)',line)
        if m:
            new_item = True
            line = m.groups(0)[0]

        if new_item:
            item = item.strip()
            if item != '':
                items.append(item)
            item = ''
            new_item = False

        item += line

#        print line.strip()

    if not return_notes:
        print notes
        return False
    return notes


def call_xsoftip(command,comp,repo):
    args = ['','','','']
    tmp = tempfile.mkdtemp()
    package = xpd_install_local_xml(repo,tmp)

    args[0] = comp.id
    args[1] = os.path.join(repo.path,comp.metainfo_path)
    args[2] = os.path.join(tmp,package.id+".xml")
    args[3] = repo.path

    cmd = ["xsoftip",command]+args
    print " ".join(cmd)
    call(cmd, cwd=repo.path, shell=True)



def xpd_build_results(repo,options,args):
    swblock_id = args[0]
    for comp in repo.get_software_blocks():
        if comp.id == swblock_id or swblock_id=='all':
            comp.init_from_path(repo,comp.path)
            check_swblock(repo, options, args, comp)
            if comp.metainfo_path:
                call_xsoftip("buildresults",comp,repo)
            else:
                print "Cannot find metadata file"


def xpd_validate_swblock(repo, options, args):
    swblock_id = args[0]
    for comp in repo.get_software_blocks():
        if comp.id == swblock_id or swblock_id=='all':
            comp.init_from_path(repo,comp.path)
            check_swblock(repo, options, args, comp)
            if comp.metainfo_path:
                call_xsoftip("validate",comp,repo)
            else:
                print "Cannot find metadata file"

def get_tools_version():
    process = Popen(["xcc","--version"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)

    err_lines = process.stderr.readlines()
    lines = process.stdout.readlines()

    try:
        m = re.match("(\d+\.\d+\.\d+).*",lines[0])
        if m:
            print "VERSION:" + m.groups(1)[0]
            return m.groups(1)[0]
    except e:
        return "development"

    return "development"

def xpd_install_local_xml(repo,cache_path):
    package = repo.create_dummy_package(repo.current_version_or_githash())
    for c in package.components:
        c.local = "true"
        c.docPartNumber = package.packagename + ".doc-" + c.id
        c.docVersion = "latest"
        if c.metainfo_path:
            shutil.copy(os.path.join(repo.path,c.metainfo_path),
                        os.path.join(cache_path,package.packagename + "-" + c.id + ".metainfo"))

        if c.buildresults_path and os.path.exists(os.path.join(repo.path,c.buildresults_path)):
            shutil.copy(os.path.join(repo.path,c.buildresults_path),
                        os.path.join(cache_path,package.packagename + "-" + c.id + ".buildresults"))
        elif c.buildresults_path:
            print "WARNING: %s has no buildresults!!" % c.name
            f = open(os.path.join(cache_path,package.packagename + "-" + c.id + ".buildresults"),"w")
            f.write("<buildresults></buildresults>");
            f.close()

    sw = SoftwareDescriptor()
    sw.id = package.id
    sw.toolsVersion = get_tools_version()
    sw.name = repo.longname
    sw.project = package.project
    sw.packages.append(package)
    f = open(os.path.join(cache_path,package.id + ".xml"),"w")
    f.write(sw.toxml("software"))
    f.close()

    all_software = AllSoftwareDescriptor()
    fpath = os.path.join(cache_path,'OfflineOnlySoftware.xml')
    if os.path.exists(fpath):
        all_software.parse(fpath)
    for p in all_software.packages:
        if p.project == repo.name:
            all_software.packages.remove(p)
    all_software.toolsVersion = sw.toolsVersion
    all_software.packages.append(package)

    f = open(fpath,"w")
    f.write(all_software.toxml("software"))
    f.close()

    f = open(os.path.join(cache_path,package.name),"w")
    f.write("dummyzip")
    f.close()
    return package

def xpd_install_local(repo, options, args):
    xpd_check_swblocks(repo, [],[])
    cache_path = os.environ['XMOS_CACHE_PATH']
    package = xpd_install_local_xml(repo,cache_path)
    print "Package installed in local cache"
    if not options.nodocs:
        print "Building documentation"

        repo.move_to_temp_sandbox(git_only=False)
        xpd_build_docs(repo, options, [], buildlatex=False)

        seealsos = ""
        i = 0;
        for doc_dir in repo.docdirs:
            i = i + 1
            local_name = package.name + "-local-doc-%d" % i
            title = xdoc.get_title(os.path.join(repo.path,doc_dir))
            dst = os.path.join(cache_path, local_name)
            if os.path.exists(dst):
                shutil.rmtree(dst)
            shutil.copytree(os.path.join(repo.path,doc_dir,'_build','xdehtml'),
                            dst)
            seealsos += '<li><a href="../%s/index.html">%s</a></li>'%(local_name,title)
            print "Installed documentation from %s" % doc_dir

        seealsos = """
        <div class="content">
        <div class="seealso">
          <h2>See Also</h2>
            <ul class="iconmenu">
            %s
            </ul>
        </div>
        </div>
        """ % seealsos

        for comp in package.components:
            zipfilepath=os.path.join(cache_path,
                                     comp.docPartNumber+"("+comp.docVersion+").zip")
            doc_dir = os.path.join(repo.path,comp.path,"_build","xdehtml")



            f = open(os.path.join(doc_dir,'README.html'))
            readme_str = f.read()
            f.close()
            readme_str = readme_str.replace("<!--seealsos-->",seealsos)
            index = open(os.path.join(doc_dir,'index.html'),'w')
            index.write(readme_str)
            index.close()
            zfile = zipfile.ZipFile(zipfilepath, 'w')
            for root, dirs, files in os.walk(doc_dir):
                for f in files:
                    fpath = os.path.join(root, f)
                    arcname = os.path.relpath(fpath, doc_dir)
                    zfile.write(fpath, arcname)
            zfile.close()
            if os.path.exists(os.path.join(cache_path,
                                     comp.docPartNumber+"("+comp.docVersion+")")):
                shutil.rmtree(os.path.join(cache_path,
                                     comp.docPartNumber+"("+comp.docVersion+")"))
            print "Installed " + zipfilepath

        repo.delete_temp_sandbox()

    return False


common_commands =  [("init","Initialize the xpd meta-information file"),
            ("status","Show current status (can also use show or info)"),
            ("update","Check and update metainformation for repository"),
            ("create_release","Create a release"),
            ("make_zip","Make zipfile of release"),
            ("upgrade_rc","Upgrade an RC to a final release"),
            ("list","List releases")]

other_commands =     [("info","Same as status"),
            ("show","Same as status"),
            ("checkout","Checkout release"),
            ("check_all","Check all meta information and infrastructure"),
            ("check_info","Check related information"),
            ("check_swblocks","Check swblocks"),
            ("validate_swblock","Validate swblock"),
            ("build_results","Build results for swblock"),
            ("tag","Tag the repo with a version"),
            ("add_dep","Add dependency"),
            ("remove_dep","Remove dependency"),
            ("check_dep","Check dependencies of the current repository"),
            ("check_infr","Check infrastructure (Makefiles, eclipse projects)"),
            ("check_makefiles","Check makefiles"),
            ("create_app","Create application within project"),
            ("update_readme","Update README.rst with latest metainformation"),
            ("create_module","Create module within project"),
            ("install_local","Install into local xsoftipexploer cache (DEBUG)"),
            ("check_partinfo","Check part information (DEBUG)"),
            ("make_docholder","Make docholder (DEBUG)"),
            ("build_docs","Make docs (DEBUG)"),
            ("build_topdoc","Make toplevel docs (DEBUG)"),
            ("parse_release_notes","Parse release notes (DEBUG)"),
            ("create_warnings","Create release warnings list (DEBUG)"),
            ("gen_package_xml","Generate package xml (DEBUG)")]


def get_git_dir(path):
    process = Popen(["git","rev-parse","--show-cdup"],
                    cwd=path,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)

    err_lines = process.stderr.readlines()
    lines = process.stdout.readlines()

    if lines == []:
        git_dir = path
    else:
        git_dir = os.path.abspath(os.path.join(path,lines[0][:-1]))

    return git_dir

if __name__ == "__main__":
    usage = "usage: %prog command [options]"
    usage += "\n\nMost useful commands:\n\n"
    for c in common_commands:
        usage += "%20s: %s"%(c[0],c[1])

        usage += "\n"

    usage += "\n\nOther commands:\n\n"
    for c in other_commands:
        usage += "%20s: %s"%(c[0],c[1])

        usage += "\n"

    optparser = OptionParser(usage=usage)

    optparser.add_option("-r","--release-version",dest="release_version",
                         help="release version")

    optparser.add_option("-t","--release-type",dest="release_type",
                         help="release type: release, alpha, beta or rc")

    optparser.add_option("-b","--branch",dest="release_branch",
                         help="release branch name")

    optparser.add_option("--oldstyle",dest="old_style",action="store_true",default=False,
                         help="create an old style zip")

    optparser.add_option("--force",dest="force",action="store_true",default=False,
                         help="Ignore safety check")

    optparser.add_option("--upload",dest="upload",action="store_true",default=False,
                         help="Upload package to document managament system")

    optparser.add_option("--nobuild",dest="nobuild",action="store_true",default=False,
                         help="Do not build when creating a release/package")

    optparser.add_option("--nodocs",dest="nodocs",action="store_true",default=False,
                         help="Do not build docs when creating a release/package")

    optparser.add_option("--nocheckdep",dest="nocheckdep",action="store_true",default=False,
                         help="Do not check repo dependencies on update")


    if len(sys.argv) > 1 and sys.argv[1] == 'git':
        repo = Repo(".")
        xpd_dep_iter(repo, ' '.join(sys.argv[1:]))
        sys.exit(0)

    (options, args) = optparser.parse_args()



    if len(args) < 1:
        optparser.error("incorrect number of arguments")

    git_dir = get_git_dir('.')
    os.chdir(git_dir)


    repo = Repo(".")

    command = args[0]

    if command == "help":
        optparser.print_help()
        sys.exit(0)

    args = args[1:]

    commands = common_commands + other_commands

    if command in [c[0] for c in commands]:
        command_fn = eval("xpd_%s" % command)
        if command_fn(repo, options, args):
            repo.save()
    else:
        matches = difflib.get_close_matches(command, commands)
        sys.stderr.write("Unknown command %s.\n" % command)
        if matches != []:
            sys.stderr.write("Did you mean one of:\n")
            for m in matches:
                sys.stderr.write("   %s\n" % m)

