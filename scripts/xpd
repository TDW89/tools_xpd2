#!/usr/bin/python
from stat import ST_MODE
from stat import S_IWRITE

from optparse import OptionParser
import os, subprocess, sys, re
import difflib
import zipfile
import tempfile
from copy import copy
from xpd.xpd_data import Repo, Release, Version, Dependency

def samefile(fileA, fileB):
    try:
        return os.path.samefile(fileA, fileB)
    except AttributeError:
        return os.path.abspath(fileA).lower() == os.path.abspath(fileB).lower()


def confirm(msg, default=False):
    x = raw_input(msg)
    if (x in ["n","N","no","No","NO"]):
        return False
    if (x in ["y","Y","yes","Yes","YES"]):
        return True
    return default


def xpd_dep_iter(repo, command, output_repo_names=True):
    deps = repo.dependencies
    os.system(command)
    for dep in deps:
        cwd = os.getcwd()
        os.chdir(dep.get_local_path())
        if output_repo_names:
            sys.stdout.write("\n"+str(dep)+":\n")
        os.system(command)
        os.chdir(cwd)

def xpd_show_dep(repo, options, args):

    if repo.dependencies == []:
        print "No dependencies"
    else:
        print "Actual:"
        for dep in repo.dependencies:
            if dep.repo:
                rel = dep.repo.current_release()
                if dep.repo.has_local_modifications():
                    local_mod = "(local modifications)"
                else:
                    local_mod = ""
                if rel:
                    print "%20s: %s %s"%(dep.repo, rel.version, local_mod)
                else:
                    print "%20s: %s %s"%(dep.repo, dep.repo.current_githash(),local_mod)

        print "\nExpected:"
        for dep in repo.dependencies:
            if dep.version_str:
                print "%20s: %s"%(dep.repo_name, dep.version_str)
            else:
                print "%20s: %s"%(dep.repo_name, dep.githash)



def xpd_remove_dep(repo, options, args):
    if len(args) < 1:
        return False
    to_remove = args[0]
    deps = repo.dependencies

    for d in deps:
        if d.repo_name == to_remove:
            deps.remove(d)
            print "Removed"
            return True

    sys.stderr.write("%s is not a current dependency\n" % to_remove)
    return False


def get_current_modules(repo):
    makefiles = []
    for root, dirs, files in os.walk(repo.path, topdown=False):
        for f in files:
            if f=="Makefile":
                makefiles.append(os.path.join(root,f))

    modules = set([])
    for path in makefiles:
        f = open(path)
        while True:
            line = f.readline()
            if line=="":
                break
            m = re.match(r'\s*USED_MODULES\s*\+?=(.*)', line)
            if m:
                s = m.groups(0)[0]
                ms = [m for m in s.split(' ') if m != '']
                modules = modules | set(ms)
            if re.match(r'.*include.*module_xcommon', line):
                modules.add('module_xcommon')
        f.close()

    return modules

def find_current_dependencies(repo):
    modules = get_current_modules(repo)

    root_dir = os.path.join(repo.path,"..")

    repos = set([])
    for dep_repo in os.listdir(root_dir):
        repo_path = os.path.join(root_dir,dep_repo)
        if os.path.isdir(repo_path):
            for module_dir in os.listdir(repo_path):
                if os.path.isdir(os.path.join(repo_path,module_dir)):
                    if module_dir in modules:
                        modules.remove(module_dir)
                        if not samefile(repo_path, repo.path):
                            repos.add(dep_repo)

    if len(modules) != 0:
        print "WARNING: Can't find repos for the following modules:"
        for m in modules:
            print "   " + m

    return repos

def xpd_add_dep(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("ERROR: required repo name")
        exit(1)

    for dep in repo.dependencies:
        if dep.repo_name == args[0]:
            sys.stderr.write("ERROR: dependency already exists")
            exit(1)


    dep = Dependency(parent=repo)
    dep.repo_name = args[0]
    dep.repo = Repo(dep.get_local_path())
    dep.uri = dep.repo.uri()
    dep.githash = dep.repo.current_githash()
    rel = dep.repo.current_release()
    if rel:
        dep.version_str = str(rel.version)
    repo.dependencies.append(dep)
    print "Added"
    return True


def xpd_check_dep(repo, options, args, return_current_ok=False,
                   allow_updates=True):
    deps = [d.repo_name for d in repo.dependencies]

    current_ok = True
    repos = find_current_dependencies(repo)

    repos = repos - set(deps)
    update = False
    for dep_repo in repos:


        if allow_updates and \
           confirm("Add %s to dependencies (Y/n)?"%dep_repo,default=True):
            dep = Dependency(parent=repo)
            dep.repo_name = dep_repo
            dep.repo = Repo(dep.get_local_path())
            dep.uri = dep.repo.uri()
            dep.githash = dep.repo.current_githash()
            rel = dep.repo.current_release()
            if rel:
                dep.version_str = str(rel.version)
            repo.dependencies.append(dep)
            print "Added"
            update = True
        else:
            if not allow_updates:
                print "Dependency %s is not up to date" % dep_repo
            if dep_repo != "xcommon":
                current_ok = False

    for dep in [d for d in repo.dependencies if d.repo]:
        rel = dep.repo.current_release()
        if dep.githash != dep.repo.current_githash() or \
           (rel and dep.version_str != str(rel.version)):
            if allow_updates and \
               confirm("%s has new local version. Update metainformation (Y/n)?"%dep.repo_name,
                       default=True):
                dep.githash = dep.repo.current_githash()
                if rel:
                    dep.version_str = str(rel.version)
                else:
                    dep.version_str = None
                update = True
            else:
                if not allow_updates:
                    print "Dependency %s is not up to date" % dep.repo_name
                current_ok = False


    if len(repos) == 0 and current_ok and not update:
        print "Dependencies OK"

    if return_current_ok:
        return current_ok
    else:
        return update


def xpd_list(repo, options, args):
    rels = repo.releases
    rels.sort()
    rels.reverse()
    for rel in rels:
        print rel.version

def xpd_upgrade_rc(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("Requires version number.\n")
        exit(1)

    version = Version(version_str=args[0])

    version.rtype = ''
    version.rnumber = 0

    if repo.get_release(version):
        sys.stderr.write("Version already exists.\n")
        exit(1)


    rc = repo.latest_release(release_filter=lambda r: r.version.match_modulo_rtype(version) and r.version.rtype=='rc')

    if not rc:
        sys.stderr.write("Cannot find rc.\n")
        exit(1)


    if not confirm("Upgrade %s to %s. Are you sure (Y/n)?"%(rc.version,version),default=True):
        return False

    release = copy(rc)
    release.version = version

    repo.releases.append(release)
    repo.save()
    repo.record_release(release)


    ref = repo.current_gitref()

    if ref == "master":
        print "xpd data updated. Please commit to complete upgrade of rc."

    return True

def branch_candidates(repo):
    candidates = []
    latest = repo.latest_full_release()
    if latest:
        candidates.append(latest)
    latest_pre = repo.latest_pre_release()
    if latest_pre and (not latest or latest_pre > latest):
        candidates.append(latest_pre)
    return candidates

def xpd_create_release(repo, options, args):

    if repo.is_detached_head():
        sys.stderr.write("Cannot create release from detached head.\n")
        exit(1)

    if hasattr(options,'release_branch') and options.release_branch:
        create_branch = True
    else:
        create_branch = False

    if create_branch:
        candidates = branch_candidates(repo)
        if len(candidates) == 0:
            print "No candidates to branch from"
            exit(1)
        if len(candidates) == 1:
            base_release = candidates[0]
        else:
            print "Candidate releases to branch from:\n"
            for i in range(len(candidates)):
                print "   " + str(i) + ": " + str(candidates[i].version)
            print ""
            x = raw_input("Choose candidate [%d..%d]:"%(0,len(candidates)-1))
            try:
                base_release = candidates[int(x)]
            except:
                print "Invalid choice"
                exit(1)
    elif hasattr(options,'release_type') and options.release_type:
        rtype = options.release_type
    else:
        x = raw_input("Enter release type (a=alpha,b=beta,r=rc): ")
        if x in ['a','alpha']:
            rtype='alpha'
        elif x in ['b','beta']:
            rtype='beta'
        elif x in ['r','rc']:
            rtype='rc'
        elif x in ['release']:
            rtype='release'
        else:
            sys.stderr.write("Unknown release type\n")
            exit(1)

        if rtype in ['release','']:
            sys.stderr.write("Cannot create release directly - must upgrade an rc\n")
            exit(1)

    if create_branch:
        pass
    elif hasattr(options,'release_version') and options.release_version:
        version = Version(version_str=options.release_version)
    else:
        latest = repo.latest_full_release()
        if latest:
            print "Latest release: %s" % latest.version
            latest_version = latest.version
        else:
            print "There is no full release yet"
            latest_version = Version(0,0,0,0)

        print "    Next major: %s" % latest_version.major_increment()
        print "    Next minor: %s" % latest_version.minor_increment()
        print "    Next point: %s" % latest_version.point_increment()

        latest_pre = repo.latest_pre_release()
        if latest_pre and (not latest or latest_pre > latest):
            print "Latest pre-release: %s" % latest_pre.version

        x = raw_input("Enter version number: ")
        version = Version(version_str=x)



    if create_branch:
        version = base_release.version
        version.branch = options.release_branch
#        version.set_branch_rnumber(repo.releases)
    else:
        version.rtype = rtype
        version.set_rnumber(repo.releases)

    if not confirm("Create release %s. Are you sure (Y/n)?"%version,default=True):
        return False


    # Do some checks

    local_mod = False
    for r in repo.all_repos():
        if r.has_local_modifications():
            print "%s has local modifications" % r
            local_mod = True

    if local_mod:
        print "Cannot create release: uncommitted modifications"
        exit(1)

    current_ok = xpd_check_dep(repo, options, args, return_current_ok=True)

    if not current_ok:
        print "Cannot create release: dependencies not up to date"
        exit(1)


    xpd_check_info(repo, options, args)

    release = Release()
    release.version = version

    # deps = []

    # for head_dep in repo.dependencies:
    #     dep = copy(head_dep)
    #     path = dep.get_local_path()
    #     dep.gitbranch = dep.repo.current_gitbranch()
    #     dep.githash = dep.repo.current_githash()
    #     dep.uri = dep.repo.uri()
    #     if dep.repo.current_release():
    #         dep.version_str = str(dep.repo.current_release().version)
    #     deps.append(dep)

    # release.dependencies = deps

    release.parenthash = repo.current_githash()

    repo.releases.append(release)

    print "Created release %s" % str(release.version)

    repo.save_and_commit_release(release)

    release.githash = repo.get_child_hash(release.parenthash)

    if confirm("Do you want to make a zipfile (Y/n)? ",default=True):
        xpd_make_zip(repo,options,[])

    return False



def do_exports(repo):
    for export in repo.exports:
        print "Exporting %s" % export
        subprocess.call(["xmake","export"],cwd = os.path.join(repo.path,export))
    return repo.exports

def xpd_make_zip(repo, options, args):

    # Do some checks

    old_style = options.old_style

    if old_style:
        oldstyle_includes = get_current_modules(repo)
        for x in os.listdir(repo.path):
            if re.match('app_.*',x):
                oldstyle_includes.add(x)
        oldstyle_root = repo.name
    else:
        oldstyle_includes = []
        oldstyle_root = None

    alternate_name = False

    local_mod = False
    for r in repo.all_repos():
        if r.has_local_modifications():
            print "%s has local modifications" % r
            local_mod = True

    if local_mod and not options.force:
        print "Cannot make zip: uncommitted modifications"
        exit(1)

    current_ok = xpd_check_dep(repo, options, args, return_current_ok=True,
                                allow_updates=False)

    if not current_ok:
        print "warning: Current dependency versions do not match meta-data"
        alternate_name = True

    rel = repo.current_release()
    if rel:
        vstr = str(rel.version)
    else:
        vstr = repo.current_githash()

    if alternate_name:
        vstr = raw_input("Please give a name for this snapshot: ")

    if old_style:
        vstr += "_flat"

    name = repo.name + "_" + vstr

    print "Building repo"
#    ret = subprocess.call(["xmake","all"], cwd=repo.path, shell=True)
    ret = 0
    if ret != 0:
        print "Error building"
        exit(1)

    exports = []
    exports += do_exports(repo)
    for dep in repo.dependencies:
        exports += do_exports(dep.repo)


    fname = name + ".zip"
    print "Creating %s" % fname

    f = zipfile.ZipFile(fname,"w")

    zip_repo(repo, f, exports, old_style,oldstyle_includes,oldstyle_root,include_binaries=True, force=options.force)
    for dep in repo.dependencies:
        zip_repo(dep.repo, f, exports, old_style,oldstyle_includes,oldstyle_root, force=options.force)

    info_string = "<zipinfo>\n"
    info_string += "   <main>%s</main>\n"%repo.name
    if not alternate_name:
        info_string += "   <version>%s</version>\n"%vstr
    info_string += "</zipinfo>"

    if not old_style:
        f.writestr('.zipinfo',info_string)

    f.close()

    return False

def find_files(path):
    fs = []
    for root, dirs, files in os.walk(path):
        for f in files:
            fs.append(os.path.relpath(os.path.join(root, f),path))

    return fs


def rmrf_dir(path):
    """
    Recursively delete everything under a subdir. Use with care
    """

    for root, dirs, files in os.walk(path, topdown=False):
        for f in files:
	    p = os.path.join(root,f)
	    os.chmod(p, os.stat(p)[ST_MODE] | S_IWRITE)
	    os.remove(p)
        for d in dirs:
	    p = os.path.join(root,d)
	    os.chmod(p, os.stat(p)[ST_MODE] | S_IWRITE)
	    os.rmdir(p)
    os.rmdir(path)

def zip_repo(repo, zipfile, exports, oldstyle=False, oldstyle_includes=[], oldstyle_root="",include_binaries=False, force = False):

    repo_copy_path = tempfile.mkdtemp()


    p = subprocess.Popen(["git","clone",repo.path, repo_copy_path],
                         stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    p.communicate()

    subprocess.call(["git","remote","set-url","origin",repo.uri()],cwd=repo_copy_path)

    p=subprocess.Popen(["git","checkout",repo.current_githash()], cwd=repo_copy_path,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    p.communicate()

    if force:
        lines = find_files(repo_copy_path)
        try:
            f = open(os.path.join(repo_copy_path,".gitignore"))
            excludes = [x.strip() for x in f.readlines()]
            f.close()
        except:
            excludes = []
    else:
        process = subprocess.Popen(["git","ls-files"],
                                   cwd=repo_copy_path,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        lines = process.stdout.readlines()
        excludes = []

    for f in lines:
        f = f.rstrip()
        if oldstyle:
            ok = False
            for i in oldstyle_includes:
                if os.path.commonprefix([f,i])==i:
                    ok = True
                    prefix = i
        else:
            ok = True

        for i in exports:
                if os.path.commonprefix([f,i])==i:
                    ok = False

        if re.match(".*\.git",f):
            ok = False

        for pattern in excludes:
            pattern = pattern.replace("*",".*")
            if re.match(pattern, f):
                ok = False

        if ok and f != "xpd.xml":
            if oldstyle:
                arcname = os.path.join(oldstyle_root, f)
            else:
                arcname = os.path.join(repo.name, f)

            if oldstyle and re.match('.*Makefile$',f):
                fh = open(os.path.join(repo_copy_path,f))
                lines = fh.readlines()
                for i in range(len(lines)):
                    lines[i] = lines[i].replace('xcommon/module_xcommon','module_xcommon')
                    lines[i] = lines[i].replace('../..','..')
                fh.close()
                new_makefile = ''.join(lines)
                zipfile.writestr(arcname, new_makefile)
            else:
                try:
                    zipfile.write(os.path.join(repo_copy_path, f), arcname=arcname)
                except:
                    pass

    for export in exports:
        export_path = os.path.join(repo_copy_path,export)
        export_path = os.path.join(export_path, "export")
        for root, dirs, files in os.walk(export_path):
            for f in files:
                fullpath = os.path.join(root, f)
                arcname = os.path.relpath(fullpath, export_path)
                if oldstyle:
                    arcname = os.path.join(oldstyle_root, arcname)
                else:
                    arcname = os.path.join(repo.name, arcname)

                zipfile.write(fullpath,arcname=arcname)

    if not oldstyle and repo.git_export != False:
        for root, dirs, files in os.walk(os.path.join(repo_copy_path,".git")):
            for f in files:
                fullpath = os.path.join(root, f)
                arcname=os.path.join(repo.name,os.path.relpath(root, repo_copy_path))
                arcname=os.path.join(arcname, f)
                zipfile.write(fullpath,arcname=arcname)

        zipfile.writestr(os.path.join(repo.name,"xpd.xml"), repo.toxml("xpd"))

    if include_binaries:
        for root, dirs, files in os.walk(os.path.join(repo_copy_path)):
            for f in files:
                if re.match('.*\.xe$',f):
                    fullpath = os.path.join(root, f)
                    arcname=os.path.relpath(root, repo_copy_path)
                    if oldstyle:
                        arcname = os.path.join(oldstyle_root, arcname)
                    else:
                        arcname=os.path.join(repo.name,arcname)
                    arcname=os.path.join(arcname, f)
                    zipfile.write(fullpath,arcname=arcname)

    rmrf_dir(repo_copy_path)



def xpd_show(repo, options, args):

    rel = repo.current_release()
    if rel:
        version = str(rel.version)
    else:
        version = str(repo.current_githash())

    print "INFO:\n"
    print "              Name: %s" % repo.longname
    print "           Version: %s" % version
    print "              Icon: %s" % repo.icon
    print "          Location: %s" % repo.location
    print "     Documentation: %s" % repo.doc
    print "       Description: %s" % repo.description
    if repo.git_export != None:
        print "   Export git info: %s" % repo.git_export

    print "\nDEPENDENCIES:\n"
    xpd_show_dep(repo, options, args)

    if repo.exports != []:
        print "\nEXPORTS:\n"
        for export in repo.exports:
            print "     %s" % export


def remove_indent(xs):
    return [re.match(' *(.*)',x).groups(0)[0] for x in xs]

def add_indent(n, xs):
    indent = ''.join([' ' for x in range(n)])
    return [indent + s for s in xs]

def rst_make_title(title, ch):
    underline = ''.join([ch for x in title])
    return [title,underline,'']

def xpd_gen_readme(repo, options, args):

    sep = '.. seperator'
    latest = repo.latest_release(release_filter=lambda r: r.version.rtype=='rc')
    if latest:
        full_version = latest.version
        full_version.rtype=''
    header = ['.. class:: announce instapaper_body rst wikistyle readme.rst','']

    header.extend(rst_make_title(repo.name,'.'))

    if repo.description:
        header.extend(remove_indent(repo.description.split('\n')) + [''])

    if repo.scope:
        header.extend([':Scope: %s'%repo.scope,''])

    if repo.vendor:
        header.extend([':Vendor: %s'%repo.vendor,''])

    if repo.maintainer:
        header.extend([':Maintainer: %s'%repo.maintainer,''])

    if latest:
        header.extend([':Cur. Release: %(ver)s'%{'ver':full_version},''])

    if repo.keywords and repo.keywords != []:
        keywords_str = ', '.join(repo.keywords)
        header.extend([':Keywords: %s'%keywords_str,''])

    release_details = []
    if latest:
        release_title = 'Current Release: %s' % full_version

        release_details.extend(rst_make_title(release_title,'='))
        release_details.extend([':RC: %d'%latest.version.rnumber,'',sep,''])

        rnotes = repo.get_release_notes(full_version)

        if not rnotes:
            notes = 'No release notes'
        else:
            notes = rnotes.wholeText

        release_details.extend([':Release Notes:',''])
        release_details.extend(add_indent(1,remove_indent(notes.split('\n')) + ['']))
        release_details.extend([sep,''])
        ## use cases

        for uc in repo.usecases:
            if uc.usecase_type == 'invalid':
                release_details.extend([':Invalid:',''])
            else:
                release_details.extend([':Use Case:',''])

            usecase_details = []
            usecase_title = '**'+uc.name
            if uc.usecase_type == 'general':
                usecase_title += " - Suitable for general purpose usage"
            elif uc.usecase_type == 'development':
                usecase_title += " - Suitable for development usage"
            usecase_title += '**'
            usecase_details.append(usecase_title)
            usecase_details.append('')

            if uc.toolchain and uc.toolchain.tools and uc.toolchain.tools != []:
                usecase_details.extend(['** Compatible Tools **',''])
                usecase_details.extend([', '.join(uc.toolchain.tools),''])

            if uc.devices and uc.devices.devices and uc.devices.devices != []:
                usecase_details.extend(['** Compatible Devices **',''])
                usecase_details.extend([', '.join(uc.devices.devices),''])

            release_details.extend(add_indent(4,usecase_details))





    changelog = []

    if repo.changelog != []:
        changelog = rst_make_title('Release History','=')

        for x in sorted(repo.changelog):
            changelog.extend([':%s:'%x.version_str,''])

            log = x.wholeText.rstrip().split('\n')

            changelog.extend(log+[''])



    print '\n'.join(header)
    print '\n'.join(release_details)
    print '\n'.join(changelog)


def xpd_checkout(repo, options, args):
    if len(args) < 1:
        return False

    local_mod = False
    for dep in repo.dependencies:
        if dep.repo.has_local_modifications():
            print "%s has local modifications" % dep.repo_name
            local_mod = True

    if local_mod:
        exit(1)

    try:
        version = Version(version_str=args[0])
    except:
        xpd_dep_iter(repo, "git checkout %s" % args[0])
        return False

    rel = repo.get_release(version)
    githash = repo.get_child_hash(rel.parenthash)
    vrepo = repo.get_versioned_repo(version)

    vrepo.checkout(githash)
    for dep in vrepo.dependencies:
        dep.repo.checkout(dep.githash)


def xpd_check_info(repo, options, args):
    update = False

    if repo.description==None or repo.description=="":
        if confirm("No description found. Add one (Y/n)?",default=True):
            print "Enter paragraph description:\n"
            repo.description = raw_input()
            update = True

    if repo.icon==None:
        if confirm("No icon found. Add one (Y/n)?",default=True):
            print "Enter path to icon: "
            repo.icon = raw_input()
            update = True

    if repo.doc==None:
        if confirm("No documentation uri found. Add one (Y/n)?",default=True):
            print "Enter documentation uri: "
            repo.doc = raw_input()
            update = True

    if repo.vendor==None:
        if confirm("No vendor found. Add one (Y/n)?",default=True):
            print "Enter vendor name: "
            repo.vendor = raw_input()
            update = True

    if repo.maintainer==None:
        if confirm("No maintainer found. Add one (Y/n)?",default=True):
            print "Enter maintainer github username: "
            repo.maintainer = raw_input()
            update = True

    if repo.scope==None:
        if confirm("No project type/scope found. Add one (Y/n)?",default=True):
            print "Enter scope (prototype, example, product or reference design): "
            repo.scope = raw_input()
            update = True



    return update

def xpd_tag(repo, options, args):
    if len(args) < 1:
        sys.stderr.write("error: requires version number\n")
        exit(1)

    v = Version(version_str=args[0])

    rel = repo.get_release(v)

    relhash = repo.get_child_hash(rel.parenthash)

    if not relhash:
        sys.stderr.write("error: cannot determine release hash\n")
        exit(1)

    subprocess.call(["git","tag","v%s"%str(v),relhash],cwd=Repo.path)

    print "Tagged"

def xpd_init(repo, options, args):
    if confirm("Repo name is %s. Change (Y/n)?"%repo.longname,default=True):
        print "Enter name: "
        repo.longname = raw_input()

    xpd_check_info(repo, options, args)
    xpd_check_dep(repo, options, args)
    return True



commands = [("init","Initialize the xpd meta-information file"),
            ("check_dep","Check dependencies of the current repository"),
            ("add_dep","Add dependency"),
            ("remove_dep","Remove dependency"),
            ("create_release","Create a release"),
            ("upgrade_rc","Upgrade an RC to a final release"),
            ("list","List releases"),
            ("show","Show current state"),
            ("checkout","Checkout release"),
            ("make_zip","Make zipfile of release"),
            ("check_info","Check related information"),
            ("tag","Tag the repo with a version"),
            ("gen_readme","Generate README file for the repo")]

if __name__ == "__main__":
    usage = "usage: %prog command [options]"
    usage += "\n\nAvailable commands:\n\n"
    for c in commands:
        usage += "%20s: %s"%(c[0],c[1])

        usage += "\n"

    optparser = OptionParser(usage=usage)

    optparser.add_option("-r","--release-version",dest="release_version",
                         help="release version")

    optparser.add_option("-t","--release-type",dest="release_type",
                         help="release type: release, alpha, beta or rc")

    optparser.add_option("-b","--branch",dest="release_branch",
                         help="release branch name")

    optparser.add_option("--oldstyle",dest="old_style",action="store_true",default=False,
                         help="create an old style zip")

    optparser.add_option("--force",dest="force",action="store_true",default=False,
                         help="Ignore safety check")



    if len(sys.argv) > 1 and sys.argv[1] == 'git':
        repo = Repo(".")
        xpd_dep_iter(repo, ' '.join(sys.argv[1:]))
        exit(0)

    (options, args) = optparser.parse_args()



    if len(args) < 1:
        optparser.error("incorrect number of arguments")


    repo = Repo(".")

    command = args[0]

    if command == "help":
        optparser.print_help()
        exit(0)

    args = args[1:]

    if command in [c[0] for c in commands]:
        command_fn = eval("xpd_%s" % command)
        if command_fn(repo, options, args):
            repo.save()
    else:
        matches = difflib.get_close_matches(command, commands)
        sys.stderr.write("Unknown command %s.\n" % command)
        if matches != []:
            sys.stderr.write("Did you mean one of:\n")
            for m in matches:
                sys.stderr.write("   %s\n" % m)

